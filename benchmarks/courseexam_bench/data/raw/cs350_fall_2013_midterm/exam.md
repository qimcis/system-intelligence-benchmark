# CS350 Fall 2013 Midterm

```json
{
  "exam_id": "cs350_fall_2013_midterm",
  "test_paper_name": "CS350 Fall 2013 Midterm",
  "course": "CS350",
  "institution": "University of Waterloo",
  "year": 2013,
  "score_total": 70,
  "num_questions": 18
}
```

---

## Question 1a [2 point(s)]

a.(2 mark(s))Explain how Mesa-style condition variables differ from Hoare-style condition variables.

```json
{
  "problem_id": "1a",
  "points": 2,
  "type": "Freeform",
  "tags": ["synchronization","condition-variables","mesa_vs_hoare"],
  "answer": "Mesa-style: signal wakes a waiter which then must re-acquire the lock (signaler continues); Hoare-style: signal transfers control and lock immediately to a waiting thread so it resumes right away.",
  "llm_judge_instructions": "Award 1 point for mentioning that Mesa signals wake waiters but do not transfer the lock (the signaler continues). Award 1 point for mentioning that Hoare-style signals transfer control (and the lock) to the waiting thread so it resumes immediately. Partial credit (1 point) if only one of these distinctions is correctly stated."
}
```

---

## Question 1b [2 point(s)]

b.(2 mark(s))How does a syscall differ from a normal function call? Identify two distinct differences.

```json
{
  "problem_id": "1b",
  "points": 2,
  "type": "Freeform",
  "tags": ["system-call","os","kernel"],
  "answer": "A syscall transfers control to kernel code and typically involves a privilege level change; a normal function call stays in user space and does not change privilege level. Syscalls often involve context switches and special calling conventions, while function calls do not.",
  "llm_judge_instructions": "Award 1 point for noting that syscalls transfer control to the kernel and involve privileged-mode code. Award 1 point for noting that normal function calls remain in user space and do not change privilege level. Partial credit (1 point) if only one distinction is correctly stated."
}
```

---

## Question 1c [2 point(s)]

c.(2 mark(s))What is the difference between an exception and an interrupt?

```json
{
  "problem_id": "1c",
  "points": 2,
  "type": "Freeform",
  "tags": ["os","interrupts","exceptions"],
  "answer": "An exception is a synchronous event generated by the CPU as a result of instruction execution (e.g., divide by zero); an interrupt is an asynchronous event from external devices or other processors.",
  "llm_judge_instructions": "Award 1 point for stating that an exception is synchronous / caused by instruction execution. Award 1 point for stating that an interrupt is asynchronous / comes from external hardware events. Partial credit (1 point) if only one aspect is correctly stated."
}
```

---

## Question 1d [2 point(s)]

d.(2 mark(s))What does it mean to provide a “fair” implementation of a synchronization mechanism?

```json
{
  "problem_id": "1d",
  "points": 2,
  "type": "Freeform",
  "tags": ["synchronization","fairness","scheduling"],
  "answer": "Fairness means no thread is indefinitely starved and resources are granted in a predictable order (commonly FIFO); equivalently, every waiter eventually makes progress.",
  "llm_judge_instructions": "Award 1 point for stating that fairness prevents starvation (each thread eventually proceeds). Award 1 point for stating that fairness implies a predictable ordering (e.g., FIFO) or bounded waiting. Partial credit (1 point) for mentioning one of these concepts correctly."
}
```

---

## Question 1e [2 point(s)]

e.(2 mark(s))In a system that implements paging, the processor uses 37-bit virtual addresses, 44-bit physical addresses and a page size of 16 kilobytes (2^14 bytes). For the physical address, how many bits are needed to represent the offset, and how many bits are needed to represent the frame number. Explain

```json
{
  "problem_id": "1e",
  "points": 2,
  "type": "Freeform",
  "tags": ["virtual-memory","paging","addressing"],
  "answer": "Offset = 14 bits (because page size is 2^14). Frame number = 44 - 14 = 30 bits.",
  "llm_judge_instructions": "Award 1 point for correctly stating offset = 14 bits. Award 1 point for correctly stating frame number = 30 bits and a brief explanation that frame number uses the remaining physical address bits (44 - 14)."
}
```

---

## Question 2 [8 point(s)]

Problem 2 (8 marks)
Consider the program below, and suppose that a single initial thread starts executing the main() function.
As the initial thread runs, additional threads are created as a result of calls to thread_fork(). Answer the questions below about the output of this concurrent program.
main() {
helper(NULL,0);
}
void
helper(void *p, unsigned long i) {  /* parameter p is not used */
if (i < 3) {
kprintf("%ld",i); /* print the value of i */
thread_fork("helper1",NULL,helper,NULL,i+1); /* fork thread to run helper(NULL,i+1) */
thread_fork("helper2",NULL,helper,NULL,i+1); /* fork thread to run helper(NULL,i+1) */
}
/* was i=0, as announced this should be i==0 */
if (i==0) {
kprintf("%ld",i);
}
thread_exit();
}

Which of the following outputs could possibly be generated by the concurrent program shown above? Write YES after each output that could possibly be generated, and write NO after each output that could not possibly be generated.
Note: to avoid rewarding random guessing, the marking scheme for this question awards points only for 5 or more correct answers.
a. 01221220
b. 01120222
c. 01342560
d. 01222120
e. 01122220
f. 01234560
g. 01212220
h. 00112222

```json
{
  "problem_id": "2",
  "points": 8,
  "type": "Freeform",
  "tags": ["concurrency","threading","fork"],
  "answer": "A, B, E, G, H",
  "llm_judge_instructions": "Award 1 point for each correct identification of options A, B, E, G, and H (up to 5 points). If the student selects all five correct options and selects no incorrect options, award an additional 3 bonus points. Total maximum = 8 points. No penalties for selecting incorrect options except that selecting incorrect options prevents the 3-point bonus."
}
```

---

## Question 3 [8 point(s)]

Problem 3 (8 marks)
For the program shown below, fill in the table at the bottom of the page to show the output that would be printed by both the parent and child processes. Briefly explain how you arrived at your solution.
int x;
main()
{
int rc;
x = 0;
rc = fork();
if (rc == 0) {
x = 10;
printf("A: %d\n", x);
} else {
printf("B: %d\n", x);
x = 100;
}
printf("C: %d\n", x);
}
A) Parent: B: 0; C: 100
   Child: A: 10; C: 10
B) Parent: B: 0; C: 0
   Child: A: 10; C: 10
C) Parent: B: 0; C: 0
   Child: A: 10; C: 100
D) Parent: B: 0; C: 100
   Child: A: 10; C: 100

```json
{
  "problem_id": "3",
  "points": 8,
  "type": "Freeform",
  "tags": ["processes","fork","execution"],
  "answer": "Parent: B: 0; C: 100. Child: A: 10; C: 10.",
  "llm_judge_instructions": "Award 4 points if the parent outputs are exactly 'B: 0' followed by 'C: 100'. Award 4 points if the child outputs are exactly 'A: 10' followed by 'C: 10'. Partial credit: if only one process's outputs are completely correct, award 4 points; otherwise 0 for that portion."
}
```

---

## Question 5 [13 point(s)]

Problem 5 (13 marks)
Suppose that a system initially has only a single thread (T1), which is running the function f1(). f1() calls thread_fork() to create a new thread, T2, to run function f2() concurrently with T1. These two threads and the functions they execute are illustrated in the two columns of the figure below.
As illustrated in the figure, thread T1 calls function fb(), and thread T2 calls functions fa() and fc().
Your task is to synchronize the calls to fa(), fb(), and fc() so that the following synchronization rules are enforced:
• function fa() finishes before function fb() is called, and
• function fb() finishes before function fc() is called.
Show how to use semaphore(s) to enforce these synchronization rules by adding P() and V() calls in suitable places in functions f1() and f2() in the diagram below. You must also declare (at the top of the diagram) global variables to point to any semaphores you use in your solution. Finally, you must include sem_create calls in suitable places in f1() and/or f2() to create and initialize the semaphores you need. Be sure that your sem_create() calls show the initial semaphore value for each newly created semaphore.
Do not use any synchronization primitives or techniques other than semaphores. Keep your solution as simple as possible - unnecessarily complex solutions may be penalized.

```json
{
  "problem_id": "5",
  "points": 13,
  "type": "Freeform",
  "tags": ["semaphores","synchronization","threading"],
  "answer": "Declare semaphores sa and sb. In f1() create sa = sem_create(\"sa\",0); sb = sem_create(\"sb\",0); After starting T2: P(sa); fb(); V(sb); In f2(): fa(); V(sa); P(sb); fc();",
  "llm_judge_instructions": "Award 2 points for correctly declaring the required semaphores (names and purpose). Award 3 points for sem_create calls placed correctly with correct initial values (both initialized to 0). Award 4 points for correct placement of P/V to ensure fa() finishes before fb() is called. Award 4 points for correct placement of P/V to ensure fb() finishes before fc() is called. Total = 13 points."
}
```

---

## Question 6a [3 point(s)]

Problem 6a (3 marks)
Suppose that the spinlock implementation is as in OS/161, which means in particular that interrupts are disabled when a thread acquires the spinlock and enabled again when the spinlock is released. Suppose that Ta and Tb are timesharing the processor in a system with only one processor. In the worst case, what is the maximum amount of time that Tb will have to spin in spinlock_acquire()? Express your answer in terms of c and q, and briefly justify your answer by identifying a situation in which Tb would have to spin that long.

```json
{
  "problem_id": "6a",
  "points": 3,
  "type": "Freeform",
  "tags": ["spinlock","os161","synchronization"],
  "answer": "0 (Tb will not spin) because with interrupts disabled on the lock holder in a single-processor timesharing system the lock holder cannot be preempted by the timer while holding the lock, so Tb cannot spin while the holder runs.",
  "llm_judge_instructions": "Award 2 points for stating the worst-case spin time is 0. Award 1 point for a correct justification explaining that with interrupts disabled a thread holding the spinlock on a single processor cannot be preempted, so other threads will not spin waiting while the holder runs. Total = 3 points."
}
```

---

## Question 6b [3 point(s)]

Problem 6b (3 marks)
Repeat part (a), but this time under the assumption that the system has two processors, and that Ta and Tb are running on different processors.

```json
{
  "problem_id": "6b",
  "points": 3,
  "type": "Freeform",
  "tags": ["spinlock","os161","multiprocessor"],
  "answer": "c (Tb can spin for the duration that Ta holds the lock, which is at most c).",
  "llm_judge_instructions": "Award 2 points for stating the worst-case spin time is c. Award 1 point for justification that on two processors Tb can actively spin while Ta holds the lock for up to the duration c. Total = 3 points."
}
```

---

## Question 6c [3 point(s)]

Problem 6c (3 marks)
Suppose that the spinlock implementation is similar to the one in OS/161, except that interrupts are not disabled while a thread holds the spinlock. Suppose that Ta and Tb are timesharing the processor in a system with only one processor. In the worst case, what is the maximum amount of time that Tb will have to spin when it calls spinlock_acquire()? Express your answer in terms of c and q, and briefly your answer by identifying a situation in which Tb would have to spin that long.

```json
{
  "problem_id": "6c",
  "points": 3,
  "type": "Freeform",
  "tags": ["spinlock","os161","interrupts"],
  "answer": "q (Tb may spin for up to one quantum q if the lock holder is preempted while holding the lock).",
  "llm_judge_instructions": "Award 2 points for stating the worst-case spin time is q. Award 1 point for justification explaining that if the lock holder is preempted while holding the lock, the spinner may spin for the duration of the preempted thread's remaining quantum q before the holder resumes and releases the lock. Total = 3 points."
}
```

---

## Question 7a [8 point(s)]

Problem 7a (8 marks)
a.(8 mark(s))Assume that each of the functions below (FuncA, FuncB, and FuncC) are being executed by different threads using the OS/161 kernel thread library. Assume that reader/writer locks have been implemented as described in the course notes and in class. Add calls to rwlock_acquire(rwlock *lk, READ_MODE) or rwlock_acquire(rwlock *lk, WRITE_MODE), and rwlock_release(rwlock *lk) and only those calls to ensure that FuncA, FuncB, and FuncC are atomic. The locks have already been declared and initialized and xlock, ylock, and zlock must be used to protect the variables x, y, and z, respectively. Additionally, your locks must not use WRITE_MODE unnecessarily, AND you must ensure that deadlock can not occur.

```json
{
  "problem_id": "7a",
  "points": 8,
  "type": "Freeform",
  "tags": ["rwlock","concurrency","critical-section"],
  "answer": "Use a fixed global lock acquisition order (xlock then ylock then zlock). Example: FuncA acquires ylock in WRITE mode, then zlock in READ mode, does work, then releases zlock and ylock. FuncB acquires xlock in WRITE mode, then zlock in READ mode, does work, then releases zlock and xlock. FuncC acquires xlock WRITE, then ylock WRITE, then zlock READ, does work, then releases in reverse order. This consistent order prevents deadlock.",
  "llm_judge_instructions": "Award 2 points for correct locking in FuncA (appropriate modes and placement). Award 2 points for correct locking in FuncB. Award 3 points for correct locking in FuncC. Award 1 point for ensuring and stating a consistent global lock acquisition order (e.g., x then y then z) that prevents deadlock. Total = 8 points."
}
```

---

## Question 7b [2 point(s)]

b.(2 mark(s))Briefly explain why deadlock can not occur with your solution.

```json
{
  "problem_id": "7b",
  "points": 2,
  "type": "Freeform",
  "tags": ["deadlock","rwlock","concurrency"],
  "answer": "Deadlock cannot occur because all functions acquire locks in a single global order (e.g., x then y then z), preventing circular wait.",
  "llm_judge_instructions": "Award 2 points if the student states that locks are acquired in a fixed global order and explains that this prevents circular wait; award 1 point for a partial but correct explanation. Total = 2 points."
}
```

---

## Question 7c [2 point(s)]

c.(2 mark(s))In your solution, which if any of the functions can be executing in their critical sections concurrently. Briefly explain your answer.

```json
{
  "problem_id": "7c",
  "points": 2,
  "type": "Freeform",
  "tags": ["rwlock","concurrency"],
  "answer": "Functions that only acquire read access on the same locks (or different locks) may run concurrently. For the given scheme, FuncA and FuncB could run concurrently if their accesses to shared variables use READ mode on any common locks; however if one holds WRITE locks that conflict, they cannot run concurrently. Explanation must reference the specific modes used.",
  "llm_judge_instructions": "Award 2 points for correctly identifying which pairs of functions can execute concurrently under the declared lock modes and for a brief justification based on lock modes and acquisition order. Award 1 point for a partially correct identification or incomplete justification. Total = 2 points."
}
```

---

## Question 8a [2 point(s)]

Problem 8 (2 marks)
a.(2 mark(s))When PID 516 is running, what is the resulting physical address for virtual address 1999?

```json
{
  "problem_id": "8a",
  "points": 2,
  "type": "Freeform",
  "tags": ["mmu","address-translation","virtual-memory"],
  "answer": "21999",
  "llm_judge_instructions": "Award 2 points for the correct physical address 21999 (calculation: 1999 + 20000 = 21999)."
}
```

---

## Question 8b [2 point(s)]

Problem 8 (2 marks)
b.(2 mark(s))When PID 516 is running, what is the resulting physical address for virtual address 2000?

```json
{
  "problem_id": "8b",
  "points": 2,
  "type": "Freeform",
  "tags": ["mmu","address-translation","virtual-memory"],
  "answer": "22000",
  "llm_judge_instructions": "Award 2 points for the correct physical address 22000 (calculation: 2000 + 20000 = 22000)."
}
```

---

## Question 8c [2 point(s)]

Problem 8 (2 marks)
c.(2 mark(s))Which virtual address, in which process, corresponds to physical address 2800? Indicate both a virtual address and a PID, or answer “NONE” if no virtual address maps to the given physical address.

```json
{
  "problem_id": "8c",
  "points": 2,
  "type": "Freeform",
  "tags": ["mmu","address-translation","virtual-memory"],
  "answer": "3600 by PID 159",
  "llm_judge_instructions": "Award 2 points if the student correctly identifies that virtual address 3600 in PID 159 maps to physical address 2800, with a brief justification using relocation/offset. Award 0 points otherwise."
}
```

---

## Question 8d [2 point(s)]

Problem 8 (2 marks)
d.(2 mark(s))Which virtual address, in which process, corresponds to physical address 7100. Indicate both a virtual address and a PID, or answer “NONE” if no virtual address maps to the given physical address.

```json
{
  "problem_id": "8d",
  "points": 2,
  "type": "Freeform",
  "tags": ["mmu","address-translation","virtual-memory"],
  "answer": "NONE",
  "llm_judge_instructions": "Award 2 points for the answer NONE with a brief justification that no process's relocation/limit range includes physical address 7100. Award 0 points otherwise."
}
```

---

## Question 8e [2 point(s)]

Problem 8 (2 marks)
e.(2 mark(s))If process 100 is running and a context switch occurs to process 230, briefly describe the steps the kernel takes to set up the MMU.

```json
{
  "problem_id": "8e",
  "points": 2,
  "type": "Freeform",
  "tags": ["mmu","context-switch","address-translation"],
  "answer": "Load the new process's limit (max) register and relocation (base) register with process 230's values (e.g., load limit=process230_limit and relocation=process230_reloc).",
  "llm_judge_instructions": "Award 1 point for describing that the kernel loads the new process's limit (max) register. Award 1 point for describing that the kernel loads the new process's relocation/base register. Total = 2 points."
}
```