# CS 350 Fall 2013 Midterm

```json
{
  "exam_id": "cs350_fall_2013_midterm",
  "test_paper_name": "CS 350 Fall 2013 Midterm",
  "course": "CS 350",
  "institution": "University of Waterloo",
  "year": 2013,
  "score_total": 57,
  "num_questions": 8
}
```

---

## Question 1 [10 point(s)]

Problem 1 (10 marks)

a.(2 mark(s)) Explain how Mesa-style condition variables differ from Hoare-style condition variables.

b.(2 mark(s)) How does a syscall differ from a normal function call? Identify two distinct differences.

c.(2 mark(s)) What is the difference between an exception and an interrupt?

d.(2 mark(s)) What does it mean to provide a “fair” implementation of a synchronization mechanism?

e.(2 mark(s)) In a system that implements paging, the processor uses 37-bit virtual addresses, 44-bit physical addresses and a page size of 16 kilobytes (2^14 bytes). For the physical address, how many bits are needed to represent the offset, and how many bits are needed to represent the frame number. Explain

```json
{
  "problem_id": "1",
  "points": 10,
  "type": "Freeform",
  "tags": ["operating-systems","concurrency","memory-management","paging"],
  "answer": "a: Mesa-style vs Hoare-style: Mesa-style condition variables allow the signaling thread to continue while the waiting thread remains on the queue; Hoare-style signals hand off the lock to a waiting thread which runs immediately. b: (i) System call transfers control to kernel/privileged code, while normal function calls run in user space; (ii) System calls may switch to privileged mode and may trap into kernel, while function calls do not. c: An exception is triggered by execution of an instruction; an interrupt is asynchronous, typically from a device or another processor. d: A fair implementation prevents starvation or enforces strict FIFO ordering for granting access to the critical section. e: Offset bits = 14 (page size 16KB = 2^14); frame number bits = 44 - 14 = 30. Explain: page size fixes offset; physical address space uses 44 bits, so remaining bits are frame number.",
  "llm_judge_instructions": "Award 2 pts for (a) correct description of Mesa vs Hoare semantics; 2 pts for (b) two distinct differences between syscall and function call; 2 pts for (c) correct distinction between exception and interrupt; 2 pts for (d) correct definition of fairness (e.g., prevents starvation or FIFO); 2 pts for (e) correct offset (14 bits) and frame-number bits (30 bits) with brief justification."
}
---
## Question 2 [8 point(s)]

Problem 2 (8 marks)

Consider the program below, and suppose that a single initial thread starts executing the main() function. As the initial thread runs, additional threads are created as a result of calls to thread_fork(). Answer the questions below about the output of this concurrent program.

main() {
helper(NULL,0);
}
void
helper(void *p, unsigned long i) {  /* parameter p is not used */
if (i < 3) {
kprintf("%ld",i); /* print the value of i */
thread_fork("helper1",NULL,helper,NULL,i+1); /* fork thread to run helper(NULL,i+1) */
thread_fork("helper2",NULL,helper,NULL,i+1); /* fork thread to run helper(NULL,i+1) */
}
/* was i=0, as announced this should be i==0 */
if (i==0) {
kprintf("%ld",i);
}
thread_exit();
}

Which of the following outputs could possibly be generated by the concurrent program shown above? Write YES after each output that could possibly be generated, and write NO after each output that could not possibly be generated.
Note: to avoid rewarding random guessing, the marking scheme for this question awards points only for 5 or more correct answers.

a. 01221220
b. 01120222
c. 01342560
d. 01222120
e. 01122220
f. 01234560
g. 01212220
h. 00112222

```json
{
  "problem_id": "2",
  "points": 8,
  "type": "Freeform",
  "tags": ["concurrency","threads","fork"],
  "answer": "a: YES; b: YES; c: NO; d: NO; e: YES; f: NO; g: YES; h: YES",
  "llm_judge_instructions": "Award up to 8 points total. Award 1 point for each correct YES/NO judgment for lines (a) through (h). If the student has 5 or more correct judgments, award the full 8 points. If fewer than 5 correct, award 1 point per correct judgment (up to 4)."
}
---
## Question 3 [8 point(s)]

Problem 3 (8 marks)

For the program shown below, fill in the table at the bottom of the page to show the output that would be printed by both the parent and child processes. Briefly explain how you arrived at your solution. Assume that all function, library and system calls are successful. If you need to make additional assumptions be sure to clearly state them.

int x;
main()
{
int rc;
x = 0;
rc = fork();
if (rc == 0) {
x = 10;
printf("A: %d\n", x);
} else {
printf("B: %d\n", x);
x = 100;
}
printf("C: %d\n", x);
}

```json
{
  "problem_id": "3",
  "points": 8,
  "type": "Freeform",
  "tags": ["fork","processes","concurrency"],
  "answer": "Parent:       Child:\nB: 0          A: 10\nC: 100        C: 10\nFork creates a copy of the process so x is not shared between parent and child after fork; parent prints B:0 then later C:100, child sets x=10 and prints A:10 then C:10.",
  "llm_judge_instructions": "Award full credit (8 pts) for the correct outputs for both parent and child and a brief explanation noting that fork copies the process address space so x is not shared. Accept minor formatting variations that preserve the content."
}
---
## Question 4 [Skip]

```json
{
  "problem_id": "4",
  "points": 0,
  "type": "Freeform",
  "tags": ["skip"],
  "answer": "",
  "llm_judge_instructions": "Question skipped; no grading required."
}
```
--- 

## Question 5 [Skip]

```json
{
  "problem_id": "5",
  "points": 0,
  "type": "Freeform",
  "tags": ["skip"],
  "answer": "",
  "llm_judge_instructions": "Question skipped; no grading required."
}
```
---

## Question 6 [9 point(s)]

Problem 6 (9 marks)

Suppose that there are only two threads, Ta and Tb, running in a system. Each of the threads attempts to execute a shared critical section that is protected by a shared spinlock, by executing code like this:
spinlock_acquire(&lock)
/* execute critical section */
spinlock_release(&lock)
Each thread needs to acquire the spinlock and execute the critical section only one time, and there are no other threads running in the system.
The threads are preemptively scheduled, using a scheduling quantum of qtime units. Once a thread has acquired the spinlock, it will spend c time units executing the critical section before releasing the spinlock.
Assume that c << q.
For all of the following questions, assume that thread Ta acquires the spinlock and executes the critical section before Tb does.

a. (3 mark(s)) Suppose that the spinlock implementation is as in OS/161, which means in particular that interrupts are disabled when a thread acquires the spinlock and enabled again when the spinlock is released. Suppose that Ta and Tb are time-sharing the processor in a system with only one processor. In the worst case, what is the maximum amount of time that Tb will have to spin in spinlock_acquire()? Express your answer in terms of c and q, and briefly justify your answer by identifying a situation in which Tb would have to spin that long.

b. (3 mark(s)) Repeat part (a), but this time under the assumption that the system has two processors, and that Ta and Tb are running on different processors.

c. (3 mark(s)) Suppose that the spinlock implementation is similar to the one in OS/161, except that interrupts are not disabled while a thread holds the spinlock. Suppose that Ta and Tb are time-sharing the processor in a system with only one processor. In the worst case, what is the maximum amount of time that Tb will have to spin when it calls spinlock_acquire()? Express your answer in terms of c and q, and briefly your answer by identifying a situation in which Tb would have to spin that long.

```json
{
  "problem_id": "6",
  "points": 9,
  "type": "Freeform",
  "tags": ["spinlocks","synchronization","os161"],
  "answer": "a) In a single-processor system with interrupts disabled while holding the spinlock, Tb will spin at most 0 time units in the worst case because once Ta acquires the lock it cannot be preempted (interrupts disabled) and will run to completion of its critical section (time c) before Tb can run; Tb cannot be scheduled to spin while Ta holds the lock. b) With two processors, Tb may immediately attempt to acquire and spin until Ta releases, so the worst-case spin time is c. c) If interrupts are not disabled while holding the lock on a single processor, Ta can be preempted while holding the lock for up to a full quantum q before it resumes and finishes its critical section; thus Tb may spin up to q + c in pathological scheduling if Ta is preempted immediately after acquiring the lock and then runs its remaining critical section time c after the preemption, but under the usual assumption c << q, the dominant delay is q. Provide brief justification referencing scheduling and preemption for each case.",
  "llm_judge_instructions": "Award 3 pts for (a) correct worst-case expression and brief justification; 3 pts for (b) correct worst-case expression and brief justification; 3 pts for (c) correct worst-case expression and brief justification. Accept equivalent expressions in terms of c and q and concise scenarios that demonstrate the worst-case."
}
---
## Question 7 [12 point(s)]

Problem 7 (12 marks)

a.(8 mark(s)) Assume that each of the functions below (FuncA, FuncB, and FuncC) are being executed by different threads using the OS/161 kernel thread library. Assume that reader/writer locks have been implemented as described in the course notes and in class. Add calls to rwlock_acquire(rwlock *lk, READ_MODE) or rwlock_acquire(rwlock *lk, WRITE_MODE), and rwlock_release(rwlock *lk) and only those calls to ensure that FuncA, FuncB, and FuncC are atomic. The locks have already been declared and initialized and xlock, ylock, and zlock must be used to protect the variables x, y, and z, respectively. Additionally, your locks must not use WRITE_MODE unnecessarily, AND you must ensure that deadlock cannot occur.

b.(2 mark(s)) Briefly explain why deadlock cannot occur with your solution.

c.(2 mark(s)) In your solution, which if any of the functions can be executing in their critical sections concurrently. Briefly explain your answer.

```json
{
  "problem_id": "7",
  "points": 12,
  "type": "Freeform",
  "tags": ["reader-writer-locks","synchronization","concurrency"],
  "answer": "a) Example locking scheme (one valid solution):\nFuncA(): rwlock_acquire(&ylock, WRITE_MODE); rwlock_acquire(&zlock, READ_MODE); /* operate on y and read z */ rwlock_release(&zlock); rwlock_release(&ylock);\nFuncB(int i): rwlock_acquire(&xlock, WRITE_MODE); rwlock_acquire(&zlock, READ_MODE); /* operate on x and read z */ rwlock_release(&zlock); rwlock_release(&xlock);\nFuncC(): rwlock_acquire(&xlock, WRITE_MODE); rwlock_acquire(&ylock, WRITE_MODE); rwlock_acquire(&zlock, READ_MODE); /* operate on x,y and read z */ rwlock_release(&zlock); rwlock_release(&ylock); rwlock_release(&xlock).\nThis acquires locks in a consistent global order (x then y then z) where applicable, and uses READ_MODE for z when z is only read.\nb) Deadlock cannot occur because all code acquires locks in a consistent global order (x before y before z) so there is no circular wait. c) Functions that only need read access to the same lock (e.g., two readers of z) can execute concurrently; specifically, readers of z can run concurrently while writers of x or y exclude others as required.",
  "llm_judge_instructions": "For (a) award points for correct placement of rwlock_acquire and rwlock_release calls, use of READ_MODE when possible, and acquisition order that prevents deadlock. (b) 2 pts for explanation that consistent lock ordering prevents circular wait. (c) 2 pts for identifying which functions (readers of the same lock) can run concurrently and brief reasoning."
}
---
## Question 8 [10 point(s)]

Problem 8 (10 marks)

Suppose that a system uses a single CPU with an MMU that uses a relocation register and a max address (or address limit) register to perform dynamic relocation. Several processes are running in this system. Each process has a simple virtual address space with virtual address ranging from 0 to the maximum address (or limit address) for that process. The kernel maintains a list of processes, their maximum virtual address (limit address) and where in physical memory each process is located (the relocation address), as shown below. All of the addresses used in this problem are decimal (base 10) numbers.

PID   Max Addr   Relocation Addr
100   1000       8000
123   2000       12
159   3000       2200
230   3000       10000
393   1000       6000
516   2000       20000

Where possible perform each of the address translations described below. Assume the kernel takes the necessary steps to set up the MMU before running each process. When the address translation is not possible explain why. In all cases be sure to describe how you arrived at your answer. Assume all addresses are in decimal.

a.(2 mark(s)) When PID 516 is running, what is the resulting physical address for virtual address 1999?

b.(2 mark(s)) When PID 516 is running, what is the resulting physical address for virtual address 2000?

c.(2 mark(s)) Which virtual address, in which process, corresponds to physical address 2800? Indicate both a virtual address and a PID, or answer “NONE” if no virtual address maps to the given physical address.

d.(2 mark(s)) Which virtual address, in which process, corresponds to physical address 7100. Indicate both a virtual address and a PID, or answer “NONE” if no virtual address maps to the given physical address.

e.(2 mark(s)) If process 100 is running and a context switch occurs to process 230, briefly describe the steps the kernel takes to set up the MMU.

```json
{
  "problem_id": "8",
  "points": 10,
  "type": "Freeform",
  "tags": ["virtual-memory","address-translation","mmu"],
  "answer": "a) Physical = relocation (20000) + virtual 1999 = 21999. b) Virtual 2000 equals the limit for PID 516 (limit 2000). If limit is inclusive, translation would be 22000; if limit is exclusive, this is invalid. State assumption; assuming 0..2000 is valid, physical = 22000. c) Physical 2800 corresponds to PID 159 with virtual 600 (since 2200 + 600 = 2800), so virtual address 600 in PID 159. d) Physical 7100 maps to NONE given the listed relocations and limits (no process relocation + offset equals 7100 with a valid offset within that process's limit). e) Kernel steps: load process 230's relocation address (10000) into the relocation register and load its max-address/limit (3000) into the limit register; ensure any MMU caches/TLBs are flushed or updated as required for the hardware.",
  "llm_judge_instructions": "Award 2 pts per subpart. For (a) and (b) award pts for correct arithmetic and handling of boundary conditions (state assumption about whether limit is inclusive). For (c) and (d) award pts for correct identification of process and virtual address or NONE with justification. For (e) award pts for listing the correct MMU register updates and any required flushes."
}
---