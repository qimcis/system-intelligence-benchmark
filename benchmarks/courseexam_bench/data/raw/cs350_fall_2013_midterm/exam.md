# CS 350 Fall 2013 Midterm

```json
{
  "exam_id": "cs350_fall_2013_midterm",
  "test_paper_name": "CS 350 Fall 2013 Midterm",
  "course": "CS 350",
  "institution": "University of Waterloo",
  "year": 2013,
  "score_total": 70,
  "num_questions": 26
}
```

---

## Question 1a [2 point(s)]

Explain how Mesa-style condition variables differ from Hoare-style condition variables.

```json
{
  "problem_id": "1a",
  "points": 2,
  "type": "Freeform",
  "tags": ["condition-variables", "synchronization"],
  "answer": "In Mesa-style condition variables the thread that calls cvsignal or cvbroadcast continues execution. In Hoare-style condition variables the thread that calls cvsignal or broadcast gets blocked, gives up the lock and the thread that was waiting continues executing.",
  "llm_judge_instructions": "Award 1 point for correctly stating the Mesa-style property (signaler continues execution / no immediate transfer of control to waiter). Award 1 point for correctly stating the Hoare-style property (signaled thread runs immediately / control transferred to waiter). Total = 2 points."
}
```

---

## Question 1b [2 point(s)]

How does asyscalldiffer from a normal function call? Identify two distinct differences.

```json
{
  "problem_id": "1b",
  "points": 2,
  "type": "Freeform",
  "tags": ["system-calls"],
  "answer": "Two differences: (1) syscall transfers control to a fixed location, while a function call transfers to a caller-specified location. (2) syscall invokes kernel code, while a function call invokes application code. (3) syscall can switch to privileged mode, while a normal function call does not.",
  "llm_judge_instructions": "Award 1 point for each distinct, correct difference (up to 2 points). Valid differences include: kernel boundary/privilege change vs. user-mode call, fixed entry point for syscall vs. return address for function call, or mode/privilege change. Total = 2 points."
}
```

---

## Question 1c [2 point(s)]

What is the difference between an exception and an interrupt?

```json
{
  "problem_id": "1c",
  "points": 2,
  "type": "Freeform",
  "tags": ["interrupts-exceptions"],
  "answer": "An exception results from the execution of an instruction. An interrupt is a signal received from a device or another processor.",
  "llm_judge_instructions": "Award 1 point for stating that an exception arises from program/instruction execution. Award 1 point for stating that an interrupt originates externally (device/processor or asynchronous event). Total = 2 points."
}
```

---

## Question 1d [2 point(s)]

What does it mean to provide a “fair” implementation of a synchronization mechanism?

```json
{
  "problem_id": "1d",
  "points": 2,
  "type": "Freeform",
  "tags": ["synchronization", "fairness"],
  "answer": "Accept either: (a) Starvation is not possible, or (b) Threads get access to the critical section in a strictly FIFO order.",
  "llm_judge_instructions": "Award 2 points if the answer states either: (a) starvation is prevented (no thread can be indefinitely denied), or (b) access is strictly FIFO (bounded waiting). Award 1 point if the answer mentions fairness in general terms without stating starvation prevention or FIFO ordering. Total = 2 points."
}
```

---

## Question 1e [2 point(s)]

In a system that implements paging, the processor uses 37-bit virtual addresses, 44-bit physical addresses and a page size of 16 kilobytes (2^14 bytes). For the physical address, how many bits are needed to represent the offset, and how many bits are needed to represent the frame number. Explain your answer.

```json
{
  "problem_id": "1e",
  "points": 2,
  "type": "Freeform",
  "tags": ["paging", "address-translation"],
  "answer": "14 bits for the offset because the frame size equals the page size. Therefore 44 - 14 = 30 bits are needed for the physical frame number.",
  "llm_judge_instructions": "Award 1 point for stating offset = 14 bits. Award 1 point for stating frame number = 30 bits and briefly noting that frame number bits = physical address bits - offset bits. Total = 2 points."
}
```

---

## Question 2a [1 point(s)]

Which of the following outputs could possibly be generated by the concurrent program shown above? YES if it could, NO otherwise.

```
01221220
```

```json
{
  "problem_id": "2a",
  "points": 1,
  "type": "Freeform",
  "tags": ["concurrency"],
  "answer": "YES",
  "llm_judge_instructions": "Award 1 point if the answer is exactly 'YES' (uppercase); otherwise 0 points. Total = 1 point."
}
```

---

## Question 2b [1 point(s)]

Which of the following outputs could possibly be generated by the concurrent program shown above? YES if it could, NO otherwise.

```
01120222
```

```json
{
  "problem_id": "2b",
  "points": 1,
  "type": "Freeform",
  "tags": ["concurrency"],
  "answer": "YES",
  "llm_judge_instructions": "Award 1 point if the answer is exactly 'YES' (uppercase); otherwise 0 points. Total = 1 point."
}
```

---

## Question 2c [1 point(s)]

Which of the following outputs could possibly be generated by the concurrent program shown above? YES if it could, NO otherwise.

```
01342560
```

```json
{
  "problem_id": "2c",
  "points": 1,
  "type": "Freeform",
  "tags": ["concurrency"],
  "answer": "NO",
  "llm_judge_instructions": "Award 1 point if the answer is exactly 'NO' (uppercase); otherwise 0 points. Total = 1 point."
}
```

---

## Question 2d [1 point(s)]

Which of the following outputs could possibly be generated by the concurrent program shown above? YES if it could, NO otherwise.

```
01222120
```

```json
{
  "problem_id": "2d",
  "points": 1,
  "type": "Freeform",
  "tags": ["concurrency"],
  "answer": "NO",
  "llm_judge_instructions": "Award 1 point if the answer is exactly 'NO' (uppercase); otherwise 0 points. Total = 1 point."
}
```

---

## Question 2e [1 point(s)]

Which of the following outputs could possibly be generated by the concurrent program shown above? YES if it could, NO otherwise.

```
01122220
```

```json
{
  "problem_id": "2e",
  "points": 1,
  "type": "Freeform",
  "tags": ["concurrency"],
  "answer": "YES",
  "llm_judge_instructions": "Award 1 point if the answer is exactly 'YES' (uppercase); otherwise 0 points. Total = 1 point."
}
```

---

## Question 2f [1 point(s)]

Which of the following outputs could possibly be generated by the concurrent program shown above? YES if it could, NO otherwise.

```
01234560
```

```json
{
  "problem_id": "2f",
  "points": 1,
  "type": "Freeform",
  "tags": ["concurrency"],
  "answer": "NO",
  "llm_judge_instructions": "Award 1 point if the answer is exactly 'NO' (uppercase); otherwise 0 points. Total = 1 point."
}
```

---

## Question 2g [1 point(s)]

Which of the following outputs could possibly be generated by the concurrent program shown above? YES if it could, NO otherwise.

```
01212220
```

```json
{
  "problem_id": "2g",
  "points": 1,
  "type": "Freeform",
  "tags": ["concurrency"],
  "answer": "YES",
  "llm_judge_instructions": "Award 1 point if the answer is exactly 'YES' (uppercase); otherwise 0 points. Total = 1 point."
}
```

---

## Question 2h [1 point(s)]

Which of the following outputs could possibly be generated by the concurrent program shown above? YES if it could, NO otherwise.

```
00112222
```

```json
{
  "problem_id": "2h",
  "points": 1,
  "type": "Freeform",
  "tags": ["concurrency"],
  "answer": "YES",
  "llm_judge_instructions": "Award 1 point if the answer is exactly 'YES' (uppercase); otherwise 0 points. Total = 1 point."
}
```

---

## Question 3 [8 point(s)]

For the program shown below, fill in the table at the bottom of the page to show the output that would be printed by both the parent and child processes. Briefly explain how you arrived at your solution. Assume that all function, library and system calls are successful. If you need to make additional assumptions be sure to clearly state them.

```
int x;
main()
{
int rc;
x = 0;
rc = fork();
if (rc == 0) {
x = 10;
printf("A: %d\n", x);
} else {
printf("B: %d\n", x);
x = 100;
}
printf("C: %d\n", x);
}
```

```json
{
  "problem_id": "3",
  "points": 8,
  "type": "Freeform",
  "tags": ["processes", "fork"],
  "answer": "Parent: B: 0\nC: 100\nChild: A: 10\nC: 10\nNo other results are possible.\nFork creates a copy of the process so x is not shared.",
  "llm_judge_instructions": "Award 1 point for each correct printed line (four lines total: Parent B: 0; Parent C: 100; Child A: 10; Child C: 10) for up to 4 points. Award up to 4 additional points for the explanation: 2 points for stating that fork copies the process/address space (so variables are not shared), and 2 points for explaining how that leads to the listed outputs (e.g., parent prints B:0 then sets x=100 so prints C:100; child sets x=10 then prints A:10 and C:10). Total = 8 points."
}
```

---

## Question 4 [13 point(s)]

Suppose that a system initially has only a single thread (T1), which is running the functionf1().f1()calls
thread
fork()to create a new thread, T2, to run functionf2()concurrently with T1. These two threads
and the functions they execute are illustrated in the two columns of the figure below.
As illustrated in the figure, thread T1 calls functionfb(), and thread T2 calls functionsfa()andfc().
Your task is to synchronize the calls tofa(),fb(), andfc()so that the following synchronization rules are
enforced:
•functionfa()finishes before functionfb()is called, and
•functionfb()finishes before functionfc()is called.
Show how to use semaphore(s) to enforce these sychronization rules by addingP()andV()calls in suitable
places in functionsf1()andf2()in the diagram below. You must also declare (at the top of the diagram)
global variables to point to any semphores you use in your solution. Finally, you must includesem
create
calls in suitable places inf1()and/orf2()to create and initialize the semaphores you need. Be sure that
yoursem
create()calls show the intial semaphore value for each newly createdsemaphore.
Do not use any synchronization primitives or techniques other than sempahores. Keep your solution as simple
as possible - unnecessarily complex solutions may be penalized.

```json
{
  "problem_id": "4",
  "points": 13,
  "type": "Freeform",
  "tags": ["semaphores"],
  "answer": "/* declare any global semaphore variables you need here, like this: */\n/* struct semaphore *s1 */\nstruct sempahore *sa; /* NEW */\nstruct sempahore *sb; /* NEW */\nThread T1Thread T2\nvoid f1() {\n/* NEW create with initial value 0 */\nsa = sem_create{\"sa\",0}; /* NEW */\nsb = sem_create{\"sb\",0}; /* NEW */\n/* create thread T2 to run f2() */\nthread_fork(...)\n/* NEW wait for fa() to finish */\nP(sa);  /* NEW */\n/* call function fb() */\nfb();\n/* NEW signal fb() is finished */\nV(sb);  /* NEW */\nthread_exit();\n}\nvoid f2() {\n/* call function fa() */\nfa();\n/* NEW signal fa() is finished */\nV(sa);  /* NEW */\n/* NEW wait for fb() to finish */\nP(sb); /* NEW */\n/* call function fc() */\nfc();\nthread_exit();\n}\n",
  "llm_judge_instructions": "Award points according to the following rubric (total = 13): 5 points for correctly declaring and creating semaphores with the correct initial values (two semaphores, both initialized to 0). 4 points for correctly enforcing 'fa finishes before fb is called' (i.e., V(sa) placed after fa, and P(sa) placed before calling fb). 4 points for correctly enforcing 'fb finishes before fc is called' (i.e., V(sb) after fb and P(sb) before fc). Minor syntax differences in student code may still receive full credit as long as the semaphore logic and initial values are correct."
}
```

---

## Question 5a [3 point(s)]

Suppose that the spinlock implementation is as in OS/161, which means in particular that interrupts are disabled when a thread acquires the spinlock and enabled again when the spinlock is released. Suppose that Ta and Tb are timesharing the processor in a system with only one processor. In the worst case, what is the maximum amount of time that Tb will have to spin in spinlock_acquire()? Express your answer in terms of c and q, and briefly justify your answer by identifying a situation in which Tb would have to spin that long.

```json
{
  "problem_id": "5a",
  "points": 3,
  "type": "Freeform",
  "tags": ["spinlocks"],
  "answer": "0",
  "llm_judge_instructions": "Award 2 points for the correct numeric answer '0'. Award 1 additional point for a brief correct justification (e.g., interrupts are disabled while Ta holds the spinlock so Ta cannot be preempted and Tb cannot be spinning while Ta holds it on a single processor). Total = 3 points."
}
```

---

## Question 5b [3 point(s)]

Repeat part (a), but this time under the assumption that the system has two processors, and that Ta and Tb are running on different processors.

```json
{
  "problem_id": "5b",
  "points": 3,
  "type": "Freeform",
  "tags": ["spinlocks"],
  "answer": "ctime units",
  "llm_judge_instructions": "Award 2 points for the correct answer 'c time units' (i.e., Tb may spin for c time units). Award 1 point for a brief justification that Tb spins until Ta releases the lock, which takes c time units. Total = 3 points."
}
```

---

## Question 5c [3 point(s)]

Suppose that the spinlock implementation is similar to the one in OS/161, except that interrupts are not disabled while a thread holds the spinlock. Suppose Ta and Tb are timesharing the processor in a system with only one processor. In the worst case, what is the maximum amount of time Tb will have to spin when it calls spinlock_acquire()? Express your answer in terms of c and q, and briefly justify your answer by identifying a situation in which Tb would have to spin that long.

```json
{
  "problem_id": "5c",
  "points": 3,
  "type": "Freeform",
  "tags": ["spinlocks"],
  "answer": "q time units",
  "llm_judge_instructions": "Award 2 points for the correct answer 'q time units'. Award 1 point for a brief correct justification (e.g., Ta may be preempted after acquiring the lock and Tb may spin for an entire time quantum q while waiting). Total = 3 points."
}
```

---

## Question 6a [8 point(s)]

Assume that each of the functions below (FuncA, FuncB, and FuncC) are being executed by different threads using the OS/161 kernel thread library. Assume that reader/writer locks have been implemented as described in the course notes and in class. Add calls to rwlock_acquire(rwlock *lk, READ_MODE) or rwlock_acquire(rwlock *lk, WRITE_MODE), and rwlock_release(rwlock *lk), and only those calls to ensure that FuncA, FuncB, and FuncC are atomic. The locks have already been declared and initialized and xlock, ylock, and zlock must be used to protect the variables x, y, and z, respectively. Additionally, your locks must not use WRITE MODE unnecessarily, AND you must ensure that deadlock can not occur.

```json
{
  "problem_id": "6a",
  "points": 8,
  "type": "Freeform",
  "tags": ["reader-writer-locks"],
  "answer": "/* NOTE: IF ONE ASSUMES THAT NO\n* OTHER CODE MODIFIES THESE\n* VARIABLES, z DOES NOT REQUIRE LOCKING */\nvolatile int x = 10;\nvolatile int y = 20;\nvolatile int z = 0;\nstruct rwlock *xlock; /* protect x */\nstruct rwlock *ylock; /* protect y */\nstruct rwlock *zlock; /* protect z */\nvoid init()\n{\nxlock = rwlock_create(\"xlock\");\n ylock = rwlock_create(\"ylock\");\n zlock = rwlock_create(\"zlock\");\n}\nvoid FuncA()\n{\n rwlock_acquire(ylock, WRITE_MODE); /* NEW */\n rwlock_acquire(zlock, READ_MODE);  /* NEW */\n if (y == 10) {\n y = y + z;\n }\n rwlock_release(zlock); /* NEW */\n rwlock_release(ylock); /* NEW */\n}\nvoid FuncB(int i)\n{\n rwlock_acquire(xlock, WRITE_MODE); /* NEW */\n rwlock_acquire(zlock, READ_MODE);  /* NEW */\n if ((i == z) || (i == x)) {\n x = z + x;\n }\n rwlock_release(zlock); /* NEW */\n rwlock_release(xlock); /* NEW */\n}\nvoid FuncC()\n{\n rwlock_acquire(xlock, WRITE_MODE); /* NEW */\n rwlock_acquire(ylock, WRITE_MODE); /* NEW */\n rwlock_acquire(zlock, READ_MODE);  /* NEW */\n x = y + x + z;\n y = z + x;\n rwlock_release(zlock); /* NEW */\n rwlock_release(ylock); /* NEW */\n rwlock_release(xlock); /* NEW */\n}",
  "llm_judge_instructions": "Award points with the following breakdown (total = 8): 3 points for FuncA having correct acquire/release calls and correct modes (WRITE for y when modifying; READ for z if only read). 3 points for FuncB having correct acquire/release calls and modes. 2 points for FuncC having correct acquire/release calls and modes and for acquiring locks in an order consistent with the other functions to avoid deadlock. Each function's points are awarded only if the locking ensures atomicity of the critical section and does not use WRITE mode unnecessarily."
}
```

---

## Question 6b [2 point(s)]

Briefly explain why deadlock can not occur with your solution.

```json
{
  "problem_id": "6b",
  "points": 2,
  "type": "Freeform",
  "tags": ["deadlock"],
  "answer": "Deadlock can not occur because locks are always acquired in the same order (x, y, z).",
  "llm_judge_instructions": "Award 2 points for explaining that all functions acquire locks in a consistent global order (e.g., x then y then z or otherwise consistent) preventing circular wait; partial credit (1 point) if explanation mentions lack of circular wait but is incomplete. Total = 2 points."
}
```

---

## Question 6c [2 point(s)]

In your solution, which if any of the functions can be executing in their critical sections concurrently. Briefly explain your answer.

```json
{
  "problem_id": "6c",
  "points": 2,
  "type": "Freeform",
  "tags": ["concurrency"],
  "answer": "FuncA and FuncB can be executed concurrently because the only shared variable between them is z and it is not modified, it is only read.",
  "llm_judge_instructions": "Award 2 points if the answer correctly identifies which functions can be concurrent and provides the correct reasoning (e.g., that they only read a shared variable or use compatible reader/writer modes). Award 1 point for a partially correct explanation. Total = 2 points."
}
```

---

## Question 7a [2 point(s)]

When PID 516 is running, what is the resulting physical address for virtual address 1999?

```json
{
  "problem_id": "7a",
  "points": 2,
  "type": "Freeform",
  "tags": ["virtual-memory"],
  "answer": "21999",
  "llm_judge_instructions": "Award 2 points if the answer is the numeric value 21999. Total = 2 points."
}
```

---

## Question 7b [2 point(s)]

When PID 516 is running, what is the resulting physical address for virtual address 2000?

```json
{
  "problem_id": "7b",
  "points": 2,
  "type": "Freeform",
  "tags": ["virtual-memory"],
  "answer": "22000",
  "llm_judge_instructions": "Award 2 points if the answer is the numeric value 22000. Total = 2 points."
}
```

---

## Question 7c [2 point(s)]

Which virtual address, in which process, corresponds to physical address 2800? Indicate both a virtual address and a PID, or answer “NONE” if no virtual address maps to the given physical address.

```json
{
  "problem_id": "7c",
  "points": 2,
  "type": "Freeform",
  "tags": ["virtual-memory"],
  "answer": "3600 by PID 159. Base addr = 2200 and 2800 was accessed so 600 is the difference. So add 600 to the base virtual address (0) = 600.",
  "llm_judge_instructions": "Award 2 points if the answer identifies VA 3600 for PID 159 (or the exact equivalent mapping). Partial credit (1 point) for correct reasoning that leads to the mapping but with an arithmetic slip. Total = 2 points."
}
```

---

## Question 7d [2 point(s)]

Which virtual address, in which process, corresponds to physical address 7100. Indicate both a virtual address and a PID, or answer “NONE” if no virtual address maps to the given physical address.

```json
{
  "problem_id": "7d",
  "points": 2,
  "type": "Freeform",
  "tags": ["virtual-memory"],
  "answer": "NONE",
  "llm_judge_instructions": "Award 2 points if the answer is 'NONE' (case-insensitive). Otherwise 0 points. Total = 2 points."
}
```

---

## Question 7e [2 point(s)]

If process 100 is running and a context switch occurs to process 230, briefly describe the steps the kernel takes to set up the MMU.

```json
{
  "problem_id": "7e",
  "points": 2,
  "type": "Freeform",
  "tags": ["virtual-memory"],
  "answer": "It needs to copy 3000 into the max addr / limit register and 10000 into the relocation reg.",
  "llm_judge_instructions": "Award 1 point for stating that the kernel updates the limit (max address) register to the new process's value (e.g., 3000). Award 1 point for stating that the kernel updates the relocation/base register to the new process's value (e.g., 10000). Total = 2 points."
}
```