# COMP 3000 Fall 2022 Final

```json
{
  "exam_id": "comp3000_fall_2022_final",
  "test_paper_name": "COMP 3000 Fall 2022 Final",
  "course": "COMP3000",
  "institution": "Carleton University",
  "year": 2022,
  "score_total": 72,
  "num_questions": 28
}
```
---
## Question 1 [2 point(s)]

In what circumstances would you expect the signal handler in 3000shell2.c to be called? Would you expect this to happen often?

```json
{
  "problem_id": "1",
  "points": 2,
  "type": "Freeform",
  "tags": ["signals"],
  "answer": "The signal handler will be called when 3000shell2 receives SIGHUP or SIGCHLD signals, because those are the signals signal_handler() has been registered for in main() (through calls to sigaction). We’d expect to get SIGHUP very rarely (e.g., when an ssh connection was terminated unexpectedly or a user sent the signal deliberately). SIGCHLD could be received every time a child process terminates, so it could happen for every external command run. As most commands will be run in the foreground, the call to wait in run_program() will take care of getting the return value of child processes, meaning the kernel doesn’t need to send a SIGCHLD to the process; however, the signal handler will definitely have to handle the SIGCHLD generated by every background process.",
  "llm_judge_instructions": "Award 1 point for identifying SIGHUP and SIGCHLD as the signals the handler handles. Award 1 point for explaining when each signal would occur (e.g., SIGHUP when a connection/session is closed; SIGCHLD when a child process terminates). Total = 2 points."
}
```
---
## Question 2 [2 point(s)]

If you strace processes on the class VM, do you generally expect to see fork system calls? Why or why not?

```json
{
  "problem_id": "2",
  "points": 2,
  "type": "Freeform",
  "tags": ["process-management"],
  "answer": "You don’t expect to see fork system calls because the C library on the class VM makes clone system calls for fork library calls.",
  "llm_judge_instructions": "Award 2 points for recognizing that fork is implemented via the clone system call on this VM; award 0 points otherwise. If the student explains briefly that libc uses clone to implement fork, give full credit."
}
```
---
## Question 3 [2 point(s)]

What determines the available internal commands for a shell? What about the available external commands?

```json
{
  "problem_id": "3",
  "points": 2,
  "type": "Freeform",
  "tags": ["shell"],
  "answer": "The availability of internal commands depends on the shell’s own implementation, since internal commands are built into the shell. External command availability depends on the programs installed in the directories listed in PATH, i.e., any executable file found along PATH can be invoked as an external command.",
  "llm_judge_instructions": "Award 2 points for correctly distinguishing internal (shell-provided) vs external (PATH-based executables); 0 points otherwise."
}
```
---
## Question 4 [5 point(s)]

For each of the following questions, answer unshare, chroot, both, or neither:(For each, 0.5 for correct unshare classification, 0.5 for correct chroot classification.)

(a)  [1] Can change how file paths are interpreted

(b)  [1] Can change the PID’s associated with processes

(c)  [1] Creates persistent files

(d)  [1] Can change how UID’s are interpreted

(e)  [1] execve’s a new executable

```json
{
  "problem_id": "4",
  "points": 5,
  "type": "Freeform",
  "tags": ["namespaces"],
  "answer": "a) unshare and chroot (both)  b) unshare  c) neither  d) unshare  e) both",
  "llm_judge_instructions": "For each part (a–e) award up to 1 point: 0.5 points if the student correctly marks whether 'unshare' applies, and 0.5 points if the student correctly marks whether 'chroot' applies. For example, for part (a) award 0.5 if they indicate unshare applies and 0.5 if they indicate chroot applies. Total across parts = 5 points."
}
```
---
## Question 5 [1 point]

When doing a call tofork(), how does the parent get the PID of the child process?

```json
{
  "problem_id": "5",
  "points": 1,
  "type": "Freeform",
  "tags": ["process-management"],
  "answer": "The return value of fork(), when greater than zero, is the PID of the child process.",
  "llm_judge_instructions": "Award 1 point for stating that fork() returns the child’s PID to the parent (positive value); 0 points otherwise."
}
```
---
## Question 6 [2 point(s)]

Is there a potential risk in running sudo busybox --install on the class VM? Why or why not? Assume you are running it in the normal student account just after login.

```json
{
  "problem_id": "6",
  "points": 2,
  "type": "Freeform",
  "tags": ["security"],
  "answer": "This command creates hard links to the busybox binary in standard executable directories using the name of many common programs. If you didn’t want to replace the standard versions with busybox’s versions you could have a significant change/loss in system functionality. Busybox checks for the existence of those files, so it only creates links for programs that don’t currently exist on the system. So this could be dangerous but in practice it isn’t.",
  "llm_judge_instructions": "Award 1 point for explaining what the command does and the potential risks (e.g., replacing many standard utilities). Award 1 point for noting BusyBox’s safety checks or mitigation (that it checks for existing files before creating links). Total = 2 points."
}
```
---
## Question 7 [8 point(s)]

Assume you run the following commands, and that the system’s root filesystem is on the device /dev/sda2 (which is where the current directory is stored):
dd if=/dev/zero of=myimage bs=8192 count=60000
mkfs.ext4 myimage
mkdir mp
mount myimage mp
dd if=/dev/urandom of=file1 bs=8192 count=2
cd mp
dd if=/dev/urandom of/file2 bs=8192 count=2

(a)  [1] Could any of the above commands cause loss of data?  Assume that nothing exists in the current directory with the name “myimage” and “mp”. (Yes or No)

(b)  [1] How manywritesystem calls were needed to create file1?

(c)  [2] Which of the above commands require root privileges? Why?

(d)  [2] What filesystem is file1 stored in? What about file2? Why?

(e)  [2] Did the creation of file1 increase the amount of data stored in /dev/sda2? What about file2? Explain briefly.

```json
{
  "problem_id": "7",
  "points": 8,
  "type": "Freeform",
  "tags": ["filesystem"],
  "answer": "a) No  b) 2  c) mount (and possibly mkfs) require root privileges because they alter filesystem state and mount points; d) file1 is stored in the root filesystem (/dev/sda2); file2 is stored in the mounted image (myimage) as its own filesystem mounted at mp; e) Yes for file1 (in /dev/sda2) and Yes for file2 (space used by the myimage filesystem also occupies storage within the root filesystem).",
  "llm_judge_instructions": "Award 1 point for (a) Yes/No correctness; 1 point for (b) exact count; 2 points for (c) correct command(s) and rationale; 2 points for (d) correct filesystem locations with justification; 2 points for (e) correct conclusion about data usage. Partial credit possible per component as described."
}
```
---
## Question 8 [2 point(s)]

Answer the following questions about x86-64 assembly language:
(a)  [1] What instruction is used to call a function?
(b)  [1] What instruction is used to make a system call?

```json
{
  "problem_id": "8",
  "points": 2,
  "type": "Freeform",
  "tags": ["assembly"],
  "answer": "a) call  b) syscall",
  "llm_judge_instructions": "Award 1 point for each part if correctly identifying the instruction used to call a function and to perform a system call. No partial credit beyond 1 point per subpart."
}
```
---
## Question 9 [1 point]

It is a common convention to follow a call to execve() with a message output to standard error. What is the purpose of such a message?

```json
{
  "problem_id": "9",
  "points": 1,
  "type": "Freeform",
  "tags": ["exec"],
  "answer": "If execve succeeds, the current program is replaced; if the subsequent code runs, execve failed, so the message indicates the failure.",
  "llm_judge_instructions": "Award 1 point for describing that the message is printed if execve fails (the process didn’t replace itself)."
}
```
---
## Question 10 [4 point(s)]

Assume a process opens a file X for writing, does an lseek that moves forward 1 MiB (2^20) bytes, does a write of 1024 null bytes, and then closes X. Answer the following questions. (Note: you may answer with expressions, you don’t have to calculate the values.)

(a)  [1] How many bytes can be read from X?

(b)  [1] How many data blocks does the file use on disk?  Assume each data block can hold 4096 bytes.

(c)  [1] For this file, which is larger, its logical or physical size?

(d)  [1] Does X have a “hole”? Yes or no.

```json
{
  "problem_id": "10",
  "points": 4,
  "type": "Freeform",
  "tags": ["filesystem"],
  "answer": "a) 1049600 bytes  b) 1 data block  c) logical  d) yes",
  "llm_judge_instructions": "Award 1 point for each subpart (a-d) as specified: (a) exact expression value or correct result; (b) number of blocks; (c) identify logical vs physical size; (d) yes/no about a hole. Partial credit not necessary beyond exact per-part scoring."
}
```
---
## Question 11 [2 point(s)]

In the confined environment, nano needs files from /lib/terminfo to function properly, while bash does not. Why does nano need them and bash doesn’t?

```json
{
  "problem_id": "11",
  "points": 2,
  "type": "Freeform",
  "tags": ["terminal"],
  "answer": "Nano uses full-screen terminal control and needs terminal capability descriptions; terminfo provides those details. Bash outputs text without screen positioning, so it does not depend on terminfo.",
  "llm_judge_instructions": "Award 2 points for recognizing terminal control needs and terminfo purpose; 0 points otherwise."
}
```
---
## Question 12 [4 point(s)]

Assume that your account is in the shadow group but has no extra privileges.
(a)  [2] Can your account validate passwords without having extra privileges? Why?
(b)  [2] Can your account delete another user account? Why?

```json
{
  "problem_id": "12",
  "points": 4,
  "type": "Freeform",
  "tags": ["security"],
  "answer": "a) Yes, because you can read /etc/shadow which contains password hashes; it can be read by shadow group members. b) No, because shadow group members cannot modify /etc/shadow or /etc/passwd or delete user home directories, which require root privileges.",
  "llm_judge_instructions": "Award 2 points for correct rationale in (a) and (b) respectively. Partial credit if partially correct per part."
}
```
---
## Question 13 [2 point(s)]

Is it safe to give full access to system devices in a confined environment? Why or why not?

```json
{
  "problem_id": "13",
  "points": 2,
  "type": "Freeform",
  "tags": ["security"],
  "answer": "No, because it would grant access to critical devices (e.g., the root filesystem’s device), enabling tampering or mounting and modifying the system.",
  "llm_judge_instructions": "Award 2 points for the safety concern and justification."
}
```
---
## Question 14 [4 point(s)]

Which of the following C functions/macros can be used from within a kernel module?  Answer yes or no for each.
(a)printf
(b)snprintf
(c)put user
(d)getpid

```json
{
  "problem_id": "14",
  "points": 4,
  "type": "Freeform",
  "tags": ["kernel-modules"],
  "answer": "a) no  b) yes  c) yes  d) no",
  "llm_judge_instructions": "Award 1 point per item (a-d) for correct yes/no. Partial credit not specified."
}
```
---
## Question 15 [2 point(s)]

After the c3000procreport module is loaded, does its code run continuously until it is unloaded? Why or why not?

```json
{
  "problem_id": "15",
  "points": 2,
  "type": "Freeform",
  "tags": ["kernel-modules"],
  "answer": "No, its code runs in response to registered events because kernel modules add code but don’t create a persistent execution context. Functions are called when /dev/procreport is accessed.",
  "llm_judge_instructions": "Award 2 points for correct explanation of event-driven execution."
}
```
---
## Question 16 [2 point(s)]

In the kernel source, current is a pointer to the task that made the system call that the kernel is currently handling. Does this pointer contain a virtual or a physical address? Explain briefly.

```json
{
  "problem_id": "16",
  "points": 2,
  "type": "Freeform",
  "tags": ["virtual-memory"],
  "answer": "Virtual address, because kernel pointers are virtual to simplify memory management; physical addresses would complicate addressing and contiguity.",
  "llm_judge_instructions": "Award 2 points for correctly identifying virtual address and giving a concise justification."
}
```
---
## Question 17 [3 point(s)]

Can abpftracescript be used to do which of the following? Answer yes or no for each.
(a)  Monitor calls to puts() made by 3000shell2.c
(b)  Monitor calls to procreport read() in c3000procreport.c
(c)  Monitor write system calls made by 3000shell2.c

```json
{
  "problem_id": "17",
  "points": 3,
  "type": "Freeform",
  "tags": ["tracing","security"],
  "answer": "a) yes  b) yes  c) yes",
  "llm_judge_instructions": "Award 1 point for each subpart correctly identified as supported by abpftracescript. Total = 3 points."
}
```
---
## Question 18 [2 point(s)]

When /dev/procreport is closed, what function in c3000procreport.c is called? How can you confirm this?

```json
{
  "problem_id": "18",
  "points": 2,
  "type": "Freeform",
  "tags": ["kernel-modules"],
  "answer": "procreportrelease() is called; confirm by adding a printk in the function or by watching the procreport trace via a debugger/trace tool.",
  "llm_judge_instructions": "Award 2 points for naming the function and giving a valid confirmation method."
}
```
---
## Question 19 [2 point(s)]

What special steps must a kernel module take before writing data to a userspace pointer? What happens in the class VM if you don’t take these steps?

```json
{
  "problem_id": "19",
  "points": 2,
  "type": "Freeform",
  "tags": ["kernel-user-space"],
  "answer": "Use kernel-space to userspace access macros (e.g., copy_to_user/put_user). Without these, the kernel may fault and log an oops.",
  "llm_judge_instructions": "Award 2 points for identifying the need to use proper macros and the consequence of not doing so."
}
```
---
## Question 20 [2 point(s)]

What is one function we can use to dynamically allocate memory in a kernel module? Why can’t we just use malloc()?

```json
{
  "problem_id": "20",
  "points": 2,
  "type": "Freeform",
  "tags": ["kernel-memory"],
  "answer": "get_free_page() is one example; malloc() cannot be used in kernel space because it relies on user-space system calls (mmap/sbrk) which are not available in the kernel.",
  "llm_judge_instructions": "Award 2 points for naming a kernel memory allocation function and explaining why malloc() is unsuitable in kernel context."
}
```
---
## Question 21 [2 point(s)]

What process’s parent is always itself? Is this process special in any other way?

```json
{
  "problem_id": "21",
  "points": 2,
  "type": "Freeform",
  "tags": ["init-system"],
  "answer": "PID 1 is the init process; its parent is itself. It is special as the first process, and it becomes the parent of orphaned processes and can trigger system shutdown on termination.",
  "llm_judge_instructions": "Award 2 points for identifying PID 1 and its special role; accept variations describing its role."
}
```
---
## Question 22 [2 point(s)]

Does the hardware running the class VM have three, four, or five level page tables? How do you know?

```json
{
  "problem_id": "22",
  "points": 2,
  "type": "Freeform",
  "tags": ["virtual-memory"],
  "answer": "Four-level page tables. Although the kernel assumes five levels for large RAM, the observed lookups show pgd and p4d identical, indicating four levels are used. The real RAM size in the VM is not enough to require five levels.",
  "llm_judge_instructions": "Award 2 points for identifying four-level page tables and giving the reasoning."
}
```
---
## Question 23 [2 point(s)]

What is a C statement or declaration that could have generated the following assembly language code? Explain how each line is accounted for in your C code.
.LC0:
.string  "alpha"
.LC1:
.string  "beta"
.LC2:
.string  "gamma"
animals:
.quad    .LC0
.quad    .LC1
.quad    0
.quad    .LC2

```json
{
  "problem_id": "23",
  "points": 2,
  "type": "Freeform",
  "tags": ["C-language"],
  "answer": "char *animals[] = {\"alpha\", \"beta\", NULL, \"gamma\"}; The strings are defined as constants and animals is an array of pointers; the NULL maps to the 0 entry.",
  "llm_judge_instructions": "Award 2 points for correctly identifying an array of string pointers with a NULL placeholder at the third position."
}
```
---
## Question 24 [4 point(s)]

Consider the following x86-64 assembly code and C code.
Assembly code:
movl the_number(%rip), %eax
cmpl %edi, %eax
jg .L6
jge .L4
leaq .LC1(%rip), %rdi
call puts@PLT
movl $-1, %eax
C code:
#include <stdio.h>
int the_number = 42;
int check_guess(int g)
{
if (g < the_number) {
puts("Higher!\n");
return 1;
} else if (g > the_number) {
puts("Lower!\n");
return -1;
} else {
puts("Got it!\n");
return 0;
}
}

(a)  [2] What part of the C code does this assembly code implement? Be specific.
(b)  [2] Could the compiler have replaced the reference to the number with the number 42? Why or why not?

```json
{
  "problem_id": "24",
  "points": 4,
  "type": "Freeform",
  "tags": ["assembly","C"],
  "answer": "a) The core of the if statement comparing g with the_number; cmpl compares g and the_number, jg and jge branch logic for the 'Higher' and 'Got it' paths, and the else branch with 'Lower!' is implemented by the remaining code. b) No, because the_number might be modified elsewhere in the program; replacing with literal 42 could be incorrect if the value changes.",
  "llm_judge_instructions": "Award 2 points for (a) precise mapping of the comparison and branches; 2 points for (b) correct justification about potential modification of the_number."
}
```
---
## Question 25 [2 point(s)]

How could you execve /bin/ls, giving it the command line argument of “-l /home”? Assume that you can use environ for the environment. Be sure to specify the exact arguments you would give to execve, defining any necessary data structures using C code.

```json
{
  "problem_id": "25",
  "points": 2,
  "type": "Freeform",
  "tags": ["exec"],
  "answer": "For argv, define: char *myargv[] = {\"ls\", \"-l\", \"/home\", NULL}; execve(\"/bin/ls\", myargv, environ);",
  "llm_judge_instructions": "Award 2 points for providing the correct argv array and calling execve with environ as the environment."
}
```
---
## Question 26 [2 point(s)]

How could you make a program “setuid student”?  What privileges would such a program have that it otherwise wouldn’t?

```json
{
  "problem_id": "26",
  "points": 2,
  "type": "Freeform",
  "tags": ["security"],
  "answer": "Change ownership to the student account and set the setuid bit (chown to student; chmod u+s). The program would then have access to the student’s files and could signal their processes, effectively gaining the user’s privileges when run by others.",
  "llm_judge_instructions": "Award 2 points for describing both ownership change and setuid bit; 0 points otherwise."
}
```
---
## Question 27 [2 point(s)]

If 3000shell2 is setuid root, does it ever give up its root privileges? If so, when? If not, what are the security implications of this?

```json
{
  "problem_id": "27",
  "points": 2,
  "type": "Freeform",
  "tags": ["security"],
  "answer": "It gives up root privileges just before running any external command unless the become command is used, by setting the child’s effective gid and uid to the real ones (as described in run_program()). This reduces privilege for external commands, but if not done carefully, could still pose a risk if the drop is mishandled.",
  "llm_judge_instructions": "Award 2 points for correctly stating when root is dropped and mention of the security implications; 0 otherwise."
}
```
---
## Question 28 [2 point(s)]

In bash, if I type “ls > logfile”, what program closes logfile, bash or ls? Why?

```json
{
  "problem_id": "28",
  "points": 2,
  "type": "Freeform",
  "tags": ["bash"],
  "answer": "ls closes the logfile because it is the one writing to the file; the file is opened by bash but passed as ls’s stdout, so ls controls the file descriptor and closes it when finished.",
  "llm_judge_instructions": "Award 2 points for correctly attributing the file closure to the program that writes to it (ls) and explaining the reason (redirection handed to ls)."
}
```