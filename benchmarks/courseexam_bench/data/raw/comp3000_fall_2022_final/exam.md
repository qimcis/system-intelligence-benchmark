# COMP 3000 Fall 2022 Final

```json
{
  "exam_id": "comp3000_fall_2022_final",
  "test_paper_name": "COMP 3000 Fall 2022 Final",
  "course": "COMP 3000",
  "institution": "Carleton University",
  "year": 2022,
  "score_total": 72,
  "num_questions": 28
}
```

---

## Question 1 [2 point(s)]

In what circumstances would you expect the signal handler in 3000shell2.c to be called? Would you expect this to happen often?

```json
{
  "problem_id": "1",
  "points": 2,
  "type": "Freeform",
  "tags": ["signals", "shell"],
  "answer": "The signal handler will be called when 3000shell2 receives SIGHUP or SIGCHLD signals, because those are the signals signal handler() has been registered for in main() (through calls to sigaction). We’d expect to get SIGHUP very rarely (say, when an ssh connection was terminated unexpectedly or a user sent the signal deliberately). SIGCHLD could be received every time a child process terminates, so it could happen for every external command run. As most commands will be run in the foreground, the call to wait in run program() will take care of getting the return value of child processes, meaning the kernel doesn’t need to send a SIGCHLD to the process; however, the signal handler will definitely have to handle the SIGCHLD generated by every backgound process.",
  "llm_judge_instructions": "Award 2 points total: 1 point for identifying SIGHUP and SIGCHLD as signals; 1 point for reasonable explanation of when each would occur. -0.5 if no mention of SIGHUP."
}
```

---

## Question 2 [2 point(s)]

If you strace processes on the class VM, do you generally expect to see fork system calls? Why or why not?

```json
{
  "problem_id": "2",
  "points": 2,
  "type": "Freeform",
  "tags": ["linux", "system-call"],
  "answer": "You don’t expect to see fork system calls because the C library on the class VM makes clone system calls for fork library calls.",
  "llm_judge_instructions": "Award 2 points for stating that fork isn’t observed and that clone is used by the C library; 1 point if only partially correct."
}
```

---

## Question 3 [2 point(s)]

What determines the available internal commands for a shell? What about the available external commands?

```json
{
  "problem_id": "3",
  "points": 2,
  "type": "Freeform",
  "tags": ["shell", "commands"],
  "answer": "The availability of internal commands depends on the code of the shell itself, as the shell implements internal commands. External command availability depends on the programs installed in the directories in the current PATH, as any available executable file can be an external command.",
  "llm_judge_instructions": "Award 2 points total: 1 point for internal commands; 1 point for external commands."
}
```

---

## Question 4 [5 point(s)]

For each of the following questions, answer unshare, chroot, both, or neither: (For each, 0.5 for correct unshare classification, 0.5 for correct chroot classification.)

(a)  [1] Can change how file paths are interpreted

(b)  [1] Can cange the PID’s associated with processes

(c)  [1] Creates persistent files

(d)  [1] Can change how UID’s are interpreted

(e)  [1] execve’s a new executable

```json
{
  "problem_id": "4",
  "points": 5,
  "type": "Freeform",
  "tags": ["security", "namespaces"],
  "answer": "a) both; b) unshare; c) neither; d) unshare; e) both",
  "llm_judge_instructions": "Award 1 point for each subpart (a)-(e) correctly classified as one of unshare, chroot, both, or neither. Total 5 points."
}
```

---

## Question 5 [1 point]

When doing a call to fork(), how does the parent get the PID of the child process?

```json
{
  "problem_id": "5",
  "points": 1,
  "type": "Freeform",
  "tags": ["processes", "fork"],
  "answer": "The return value of fork, if it is greater than zero, is the PID of the child process.",
  "llm_judge_instructions": "Award 1 point for stating that fork returns the child's PID to the parent."
}
```

---

## Question 6 [2 point(s)]

Is there a potential risk in running sudo busybox --install on the class VM? Why or why not? Assume you are running it in the normal student account just after login.

```json
{
  "problem_id": "6",
  "points": 2,
  "type": "Freeform",
  "tags": ["security", "busybox"],
  "answer": "This command creates hard links to the busybox binary in standard executable directories using the name of many common programs. If you didn’t want to replace the standard versions with busybox’s versions you could have a significant change/loss in system functionality. However, busybox checks for the existence of those files, so it only create links for programs that don’t currently exist on the system. So this could be dangerous but in practice it isn’t.",
  "llm_judge_instructions": "Award 2 points: 1 for describing the action of busybox and 1 for discussing potential risk or safety. Partial credit allowed if only one aspect explained."
}
```

---

## Question 7 [8 point(s)]

Assume you run the following commands, and that the system’s root filesystem is on the device /dev/sda2 (which is where the current directory is stored):

dd if=/dev/zero of=myimage bs=8192 count=60000
mkfs.ext4 myimage
mkdir mp
mount myimage mp
dd if=/dev/urandom of=file1 bs=8192 count=2
cd mp
dd if=/dev/urandom of=file2 bs=8192 count=2

(a)  [1] Could any of the above commands cause loss of data?  Assume that nothing exists in the current directory with the name “myimage” and “mp”. (Yes or No)

(b)  [1] How manywrites(system calls) were needed to create file1?

(c)  [2] Which of the above commands require root privileges? Why?

(d)  [2] What filesystem is file1 stored in? What about file2? Why?

(e)  [2] Did the creation of file1 increase the amount of data stored in /dev/sda2? What about file2? Explain briefly.

```json
{
  "problem_id": "7",
  "points": 8,
  "type": "Freeform",
  "tags": ["filesystem", "linux"],
  "answer": "a) No\nb) 2\nc) mount requires root privileges, because it changes the filesystems that are accessible and the system’s directory structure.\nd) file1 is stored in the root filesystem stored in /dev/sda2, because it was made in the top-level directory. file2 is in the myimage filesystem because it is mounted in the mp directory.\ne) The creation of both file1 and file2 increased the amount of data stored in /dev/sda2 because file1 is stored in the root filesystem stored in /dev/sda2, and file2 increases the space used in the myimage filesystem and that filesystem’s image is stored in the root filesystem which is stored on /dev/sda2.",
  "llm_judge_instructions": "Award 1 point for (a), 1 for (b), 2 for (c), 2 for (d), 2 for (e)."
}
```

---

## Question 8 [2 point(s)]

Answer the following questions about x86-64 assembly language:

(a)  [1] What instruction is used to call a function?

(b)  [1] What instruction is used to make a system call?

```json
{
  "problem_id": "8",
  "points": 2,
  "type": "Freeform",
  "tags": ["assembly", "x86-64"],
  "answer": "a) call\nb) syscall",
  "llm_judge_instructions": "Award 1 point for each part correctly stating the instruction."
}
```

---

## Question 9 [1 point]

It is a common convention to follow a call to execve()with a message output to standard error. What is the purpose of such a message?

```json
{
  "problem_id": "9",
  "points": 1,
  "type": "Freeform",
  "tags": ["processes", "execve"],
  "answer": "If execve succeeds, the current program is replaced with that in the file given to execve. So if the statement after the execve runs at all, it means the execve has failed—so this is a natural place to output an error because an error indeed has happened (the execve failed).",
  "llm_judge_instructions": "Award 1 point for stating that the message is to report failure if execve fails."
}
```

---

## Question 10 [4 point(s)]

Assume a process opens a file X for writing, does an lseek that moves forward 1 MiB (2^20) bytes, does a write of 1024 null bytes, and then closes X. Answer the following questions. (Note: you may answer with expressions, you don’t have to calculate the values.)

(a)  [1] How many bytes can be read from X?

(b)  [1] How many data blocks does the file use on disk?  Assume each data block can hold 4096 bytes.

(c)  [1] For this file, which is larger, its logical or physical size?

(d)  [1] Does X have a “hole”? Yes or no.

While you should have been able to figure out the answers based on your knowledge of lseek and file holes, you could have written a test program such as this:

```c
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
int main()
{
int fd;
int shift;
char buf[1024];
fd = open("testfile", O_WRONLY|O_CREAT, 0444);
shift = 1 << 20;
printf("Seeking %d\n", shift);
lseek(fd, shift, SEEK_CUR);
memset(buf, 0, 1024);
write(fd, buf, 1024);
close(fd);
return 0;
}
```

```json
{
  "problem_id": "10",
  "points": 4,
  "type": "Freeform",
  "tags": ["filesystems", "lseek"],
  "answer": "a) 1049600 bytes\nb) one data block\nc) logical\nd) yes",
  "llm_judge_instructions": "Award 1 point for each correct item."
}
```

---

## Question 11 [2 point(s)]

In the confined environment, nano needs files from /lib/terminfo to function properly, while bash, however, can function properly without these files. Why does nano need them and bash does not?

```json
{
  "problem_id": "11",
  "points": 2,
  "type": "Freeform",
  "tags": ["terminal", "terminfo"],
  "answer": "nano needs them because it operates in full-screen mode, i.e., it needs to position text at arbitrary positions in the terminal. In order to do this, it needs to know how to control the terminal, particularly where text is drawn on the screen. This is precisely what files in the terminfo directory document. bash just outputs text without regard to screen position, thus it can work on any terminal without requiring special information or having any special control.",
  "llm_judge_instructions": "Award 2 points: 1 for recognizing full-screen requirement; 1 for linking terminfos to terminal control."
}
```

---

## Question 12 [4 point(s)]

Assume that your account is in the shadow group but has no extra privileges.

(a)  [2] Can your account validate passwords without having extra privileges? Why?

(b)  [2] Can your account delete another user account? Why?

```json
{
  "problem_id": "12",
  "points": 4,
  "type": "Freeform",
  "tags": ["security", "permissions"],
  "answer": "a) Yes, because you can read /etc/shadow which has the password hashes for each account. /etc/shadow can be read by processes in the shadow group\nb) No, because members of the shadow group cannot modify /etc/shadow or /etc/passwd, and they certainly can’t delete a directory in /home, because those all require root privileges.",
  "llm_judge_instructions": "Award 2 points for each subpart, total 4."
}
```

---

## Question 13 [2 point(s)]

Is it safe to give full access to system devices in a confined environment? Why or why not?

```json
{
  "problem_id": "13",
  "points": 2,
  "type": "Freeform",
  "tags": ["security", "devices"],
  "answer": "It is not safe, because then they can get access to critical devices such as the one holding the root filesystem (and thus will be able to mount it and modify any file on the system!).",
  "llm_judge_instructions": "Award 2 points for recognizing risk to root and integrity of system."
}
```

---

## Question 14 [4 point(s)]

Which of the following C functions/macros can be used from within a kernel module? Answer yes or no for each.

(a) printf

(b) snprintf

(c) put user

(d) getpid

```json
{
  "problem_id": "14",
  "points": 4,
  "type": "Freeform",
  "tags": ["kernel", "c", "macros"],
  "answer": "a) no\nb) yes\nc) yes\nd) no",
  "llm_judge_instructions": "Award 1 point for each item correctly answered (a–d)."
}
```

---

## Question 15 [2 point(s)]

After the c3000procreport module is loaded, does its code run continuously until it is unloaded? Why or why not?

```json
{
  "problem_id": "15",
  "points": 2,
  "type": "Freeform",
  "tags": ["kernel", "modules"],
  "answer": "No, its code only runs in response to registered events because modules add code to the kernel but they don’t create a new execution context (normally). Its functions only get called when the /dev/procreport is accessed; otherwise, its code isn’t running.",
  "llm_judge_instructions": "Award 2 points for understanding event-driven nature of modules."
}
```

---

## Question 16 [2 point(s)]

In the kernel source, current is a pointer to the task that made the system call that the kernel is currently handling. Does this pointer contain a virtual or a physical address? Explain briefly.

```json
{
  "problem_id": "16",
  "points": 2,
  "type": "Freeform",
  "tags": ["kernel", "pointers"],
  "answer": "Virtual address, because except for low-level memory management all pointers in the kernel are virtual because otherwise kernel code would have to deal with its code being spread out in page-sized chunks throughout the physical address space, or it would greatly make memory management more complicated because kernel memory would all have to be allocated contiguously.",
  "llm_judge_instructions": "Award 2 points for recognizing virtual address and brief justification."
}
```

---

## Question 17 [3 point(s)]

Can a pfptracescript be used to do which of the following? Answer yes or no for each.

(a)  Monitor calls toputs()made by 3000shell2.c

(b)  Monitor calls toprocreport read()in c3000procreport.c

(c)  Monitor write system calls made by 3000shell2.c

```json
{
  "problem_id": "17",
  "points": 3,
  "type": "Freeform",
  "tags": ["monitoring", "ptrace"],
  "answer": "a) yes\nb) yes\nc) yes",
  "llm_judge_instructions": "Award 1 point for each yes, total 3."
}
```

---

## Question 18 [2 point(s)]

When /dev/procreport is closed, what function in c3000procreport.c is called? How can you confirm this?

```json
{
  "problem_id": "18",
  "points": 2,
  "type": "Freeform",
  "tags": ["kernel", "modules"],
  "answer": "procreportrelease() is called when /dev/procreport is closed, we can verify this by either adding a printk statement to put a message in the kernel log or we can observe the output of watchprocreport.bt while a program opens, pauses, and then closes /dev/procreport.",
  "llm_judge_instructions": "Award 2 points for identifying the function and describing verification method."
}
```

---

## Question 19 [2 point(s)]

What special steps must a kernel module take before writing data to a userspace pointer? What happens in the class VM if you don’t take these steps?

```json
{
  "problem_id": "19",
  "points": 2,
  "type": "Freeform",
  "tags": ["kernel", "userspace"],
  "answer": "The kernel must make sure to use the special macros/functions to access userspace such as putuser(). If it doesn’t do this the memory operation will be detected as being not allowed and will generate a kernel oops log message.",
  "llm_judge_instructions": "Award 2 points for mentioning safe access macros and the consequence if skipped."
}
```

---

## Question 20 [2 point(s)]

What is one function we can use to dynamically allocate memory in a kernel module? Why can’t we just use malloc()?

```json
{
  "problem_id": "20",
  "points": 2,
  "type": "Freeform",
  "tags": ["kernel", "memory"],
  "answer": "get_free_page() is one that we’ve seen, there are many others for allocating memory in the kernel. We can’t just use malloc() because it depends on system calls such as mmap and sbrk, and the kernel is what implement system calls so it cannot make them in order to implement its own functionality.",
  "llm_judge_instructions": "Award 2 points for naming a kernel allocation function and explaining why malloc() cannot be used."
}
```

---

## Question 21 [2 point(s)]

What process’s parent is always itself? Is this process special in any other way?

```json
{
  "problem_id": "21",
  "points": 2,
  "type": "Freeform",
  "tags": ["processes", "init"],
  "answer": "PID 1, the init process, is its own parent. It is special because it is the first process that runs when the system boots and when it terminates the system shuts down. Also, it becomes the parent of any process that loses its original parent.",
  "llm_judge_instructions": "Award 2 points for identifying PID 1 and its special role."
}
```

---

## Question 22 [2 point(s)]

Does the hardware running the class VM have three, four, or five level page tables? How do you know?

```json
{
  "problem_id": "22",
  "points": 2,
  "type": "Freeform",
  "tags": ["vm", "paging"],
  "answer": "It has four level page tables because while the Linux kernel assumes a five level page table, when we look at the lookups in procreport getphysical() pgd and p4d are identical. We can also know this because you only need 5 level page tables to handle more than 256 TiB of RAM, and the SCS servers definitely don’t have more than that!",
  "llm_judge_instructions": "Award 2 points for the four-level conclusion and justification."
}
```

---

## Question 23 [2 point(s)]

What is a C statement or declaration that could have generated the following assembly language code? Explain how each line is accounted for in your C code.

.LC0:
.string  "alpha"
.LC1:
.string  "beta"
.LC2:
.string  "gamma"
animals:
.quad    .LC0
.quad    .LC1
.quad    0
.quad    .LC2

```json
{
  "problem_id": "23",
  "points": 2,
  "type": "Freeform",
  "tags": ["c", "assembly"],
  "answer": "char *animals[] ={\"alpha\", \"beta\", NULL, \"gamma\"}; The first six lines are declaring the constant strings. “animals” labels the start of an array of four 64-bit values. All of these are pointers to the constant strings previously declared except for the third which is just a zero or NULL value.",
  "llm_judge_instructions": "Award 2 points for correct C declaration and brief explanation."
}
```

---

## Question 24 [4 point(s)]

Consider the following x86-64 assembly code and C code.
Assembly code:
movl the_number(%rip), %eax
cmpl %edi, %eax
jg .L6
jge .L4
leaq .LC1(%rip), %rdi
call puts@PLT
movl $-1, %eax
C code:
#include <stdio.h>
int the_number = 42;
int check_guess(int g)
{
if (g < the_number) {
puts("Higher!\n");
return 1;
} else if (g > the_number) {
puts("Lower!\n");
return -1;
} else {
puts("Got it!\n");
return 0;
}
}

(a)  [2] What part of the C code does this assembly code implement? Be specific.

(b)  [2] Could the compiler have replaced the reference tothe numberwith the number 42? Why or why not?

```json
{
  "problem_id": "24",
  "points": 4,
  "type": "Freeform",
  "tags": ["compiler", "assembly"],
  "answer": "a) This code implements the core of the if statement, comparing g with the number. The cmpl compares the two values, and the jg jumps to the code that implements the higher portion, the jge jumps to the got it branch code, and the rest of the code implements the lower portion, outputting the Lower! string and returning -1 (well, putting that value in the eax register to be returned).\nb) No, because other parts of the program could modify the number.",
  "llm_judge_instructions": "Award 2 points for each part (a) and (b) correctly explained."
}
```

---

## Question 25 [2 point(s)]

How could you execve /bin/ls, giving it the command line argument of “-l /home”? Assume that you can use environ for the environment. Be sure to specify the exact arguments you would give to execve, defining any necessary data structures using C code.

```json
{
  "problem_id": "25",
  "points": 2,
  "type": "Freeform",
  "tags": ["execve", "linux"],
  "answer": "For argv, you just need to define a suitable array of pointers to character arrays, with the last entry being NULL. You then give it as the second argument to execve. Code follows:\nchar *myargv[] = {\"ls\", \"-l\", \"/home\", NULL};\nexecve(\"/bin/ls\", myargv, environ);",
  "llm_judge_instructions": "Award 2 points for providing the argv array and the execve call with environ."
}
```

---

## Question 26 [2 point(s)]

How could you make a program “setuid student”?  What privileges would such a program have that it otherwise wouldn’t?

```json
{
  "problem_id": "26",
  "points": 2,
  "type": "Freeform",
  "tags": ["security", "setuid"],
  "answer": "You make a program setuid student the same as you make it setuid root: you change its ownership to student with chown and then set the setuid bit on it (chmod u+s). Such a program would have access to student’s files and could send signals to student’s processes even if it was run by another non-privileged user. (So if you made a game that other users could run, if you made it setuid your user, you could have a high score file that other users couldn’t update but your game could.)",
  "llm_judge_instructions": "Award 2 points for describing ownership change and setuid bit; 0 if incorrect."
}
```

---

## Question 27 [2 point(s)]

If 3000shell2 is setuid root, does it ever give up its root privileges? If so, when? If not, what are the security implications of this?

```json
{
  "problem_id": "27",
  "points": 2,
  "type": "Freeform",
  "tags": ["security", "setuid"],
  "answer": "3000shell2 gives up its root privileges just before running any external command unless the become command is used, specifically lines 188 and 189 in run program() which sets the child process’s effective gid and uid to the real ones, thus dropping root privileges.",
  "llm_judge_instructions": "Award 2 points for describing the privilege drop behavior and when it occurs."
}
```

---

## Question 28 [2 point(s)]

In bash, if I type “ls > logfile”, what programcloseslogfile, bash or ls? Why?

```json
{
  "problem_id": "28",
  "points": 2,
  "type": "Freeform",
  "tags": ["shell", "redirection"],
  "answer": "ls closes the logfile because it is the one actually writing to the file. The file is initially opened by bash but then is handed off as ls’s standard output; it can thus do whatever it wishes to with it and when it is done or it terminates, the file is closed.",
  "llm_judge_instructions": "Award 2 points for explaining that ls handles the output after redirection and closes the file."
}
```

---