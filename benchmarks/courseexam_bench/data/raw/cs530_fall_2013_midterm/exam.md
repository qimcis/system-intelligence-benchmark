# CS 530 Fall 2013 Midterm

```json
{
  "exam_id": "cs530_fall_2013_midterm",
  "test_paper_name": "CS 530 Fall 2013 Midterm",
  "course": "CS 530",
  "institution": "University of Waterloo",
  "year": 2013,
  "score_total": 57,
  "num_questions": 25
}
```

---

## Question 1 [2 point(s)]

Explain how Mesa-style condition variables differ from Hoare-style condition variables.

```json
{
  "problem_id": "1",
  "points": 2,
  "type": "Freeform",
  "tags": ["synchronization", "condition-variables", "os"],
  "answer": "Mesa: the signaling thread continues execution after signaling; Hoare: the signaling thread immediately yields and the waiting thread runs immediately (the signaling thread is suspended until the waiter finishes or recontends).",
  "llm_judge_instructions": "Total 2 points. Award 1 point for correctly stating the Mesa behavior (signaler continues). Award 1 point for correctly stating the Hoare behavior (signaler yields and waiter runs). If only one part is correct award 1 point; if both incorrect award 0."
}
```

---

## Question 2 [2 point(s)]

How does a syscall differ from a normal function call? Identify two distinct differences.

```json
{
  "problem_id": "2",
  "points": 2,
  "type": "Freeform",
  "tags": ["systems-calls", "privilege", "os"],
  "answer": "Syscall transfers control to a fixed kernel entry point and executes kernel code, and typically changes processor privilege level to kernel mode; a normal function call transfers control to a caller-specified address within the same privilege level and executes application code.",
  "llm_judge_instructions": "Total 2 points. Award 1 point for each distinct correct difference. Common acceptable differences: (a) syscall to fixed kernel entry vs function call to caller-specified address; (b) syscall executes kernel code vs function call executes user code; (c) syscall changes privilege level vs function call does not. Award 2 if two distinct correct differences given; 1 if one correct; 0 if none."
}
```

---

## Question 3 [2 point(s)]

What is the difference between an exception and an interrupt?

```json
{
  "problem_id": "3",
  "points": 2,
  "type": "Freeform",
  "tags": ["exceptions", "interrupts"],
  "answer": "An exception is caused by the executing instruction (e.g., divide-by-zero, page fault); an interrupt is an external event signalled by hardware or another processor (e.g., I/O completion, timer).",
  "llm_judge_instructions": "Total 2 points. Award 1 point for correctly defining an exception. Award 1 point for correctly defining an interrupt. If only one is correct award 1; if both correct award 2."
}
```

---

## Question 4 [2 point(s)]

What does it mean to provide a “fair” implementation of a synchronization mechanism?

```json
{
  "problem_id": "4",
  "points": 2,
  "type": "Freeform",
  "tags": ["synchronization", "fairness"],
  "answer": "Fairness means threads cannot be starved (every thread eventually makes progress), commonly implemented as FIFO ordering of waiting threads or other guarantees preventing indefinite postponement.",
  "llm_judge_instructions": "Total 2 points. Award 2 points if the answer states a correct definition (e.g., no starvation or FIFO access). Award 1 point for a partially correct statement that mentions progress but not starvation or FIFO. Award 0 for incorrect."
}
```

---

## Question 5 [2 point(s)]

In a system that implements paging, the processor uses 37-bit virtual addresses, 44-bit physical addresses and a page size of 16 kilobytes (2^14 bytes). For the physical address, how many bits are needed to represent the offset, and how many bits are needed to represent the frame number. Explain your answer.

```json
{
  "problem_id": "5",
  "points": 2,
  "type": "Freeform",
  "tags": ["virtual-memory", "paging"],
  "answer": "Offset = 14 bits (because page size = 2^14). Frame number bits = 44 - 14 = 30 bits.",
  "llm_judge_instructions": "Total 2 points. Award 1 point for correctly stating the offset is 14 bits. Award 1 point for correctly computing the frame number as 30 bits (44 - 14)."
}
```

---

## Question 6 [1 point(s)]

Which of the following outputs could possibly be generated by the concurrent program shown above? Write YES after each output that could possibly be generated, and write NO after each output that could not possibly be generated.

a. 01221220

```json
{
  "problem_id": "6",
  "points": 1,
  "type": "Freeform",
  "tags": ["concurrency", "threading"],
  "answer": "YES",
  "llm_judge_instructions": "1 point if the student marks this output as YES; 0 otherwise."
}
```

---

## Question 7 [1 point(s)]

b. 01120222

```json
{
  "problem_id": "7",
  "points": 1,
  "type": "Freeform",
  "tags": ["concurrency", "threading"],
  "answer": "YES",
  "llm_judge_instructions": "1 point if the student marks this output as YES; 0 otherwise."
}
```

---

## Question 8 [1 point(s)]

c. 01342560

```json
{
  "problem_id": "8",
  "points": 1,
  "type": "Freeform",
  "tags": ["concurrency", "threading"],
  "answer": "NO",
  "llm_judge_instructions": "1 point if the student marks this output as NO; 0 otherwise."
}
```

---

## Question 9 [1 point(s)]

d. 01222120

```json
{
  "problem_id": "9",
  "points": 1,
  "type": "Freeform",
  "tags": ["concurrency", "threading"],
  "answer": "NO",
  "llm_judge_instructions": "1 point if the student marks this output as NO; 0 otherwise."
}
```

---

## Question 10 [1 point(s)]

e. 01122220

```json
{
  "problem_id": "10",
  "points": 1,
  "type": "Freeform",
  "tags": ["concurrency", "threading"],
  "answer": "YES",
  "llm_judge_instructions": "1 point if the student marks this output as YES; 0 otherwise."
}
```

---

## Question 11 [1 point(s)]

f. 01234560

```json
{
  "problem_id": "11",
  "points": 1,
  "type": "Freeform",
  "tags": ["concurrency", "threading"],
  "answer": "NO",
  "llm_judge_instructions": "1 point if the student marks this output as NO; 0 otherwise."
}
```

---

## Question 12 [1 point(s)]

g. 01212220

```json
{
  "problem_id": "12",
  "points": 1,
  "type": "Freeform",
  "tags": ["concurrency", "threading"],
  "answer": "YES",
  "llm_judge_instructions": "1 point if the student marks this output as YES; 0 otherwise."
}
```

---

## Question 13 [1 point(s)]

h. 00112222

```json
{
  "problem_id": "13",
  "points": 1,
  "type": "Freeform",
  "tags": ["concurrency", "threading"],
  "answer": "YES",
  "llm_judge_instructions": "1 point if the student marks this output as YES; 0 otherwise."
}
```

---

## Question 14 [8 point(s)]

For the program shown below, fill in the table at the bottom of the page to show the output that would be printed by both the parent and child processes. Briefly explain how you arrived at your solution.

int x;
main()
{
int rc;
x = 0;
rc = fork();
if (rc == 0) {
x = 10;
printf("A: %d\n", x);
} else {
printf("B: %d\n", x);
x = 100;
}
printf("C: %d\n", x);
}

```json
{
  "problem_id": "14",
  "points": 8,
  "type": "Freeform",
  "tags": ["process", "fork", "memory"],
  "answer": "Parent prints: B: 0 (then later) C: 100. Child prints: A: 10 (then) C: 10. Explanation: fork() creates separate address spaces, so modifications to x in child do not affect parent; parent later sets x=100.",
  "llm_judge_instructions": "Total 8 points. Award up to 4 points for correct outputs: 2 points if parent outputs are exactly 'B: 0' then 'C: 100' in that order; 2 points if child outputs are exactly 'A: 10' then 'C: 10' in that order. Award up to 4 points for explanation: 2 points for stating that fork creates separate copies of memory and child changes do not affect parent, 2 points for explaining why parent prints C:100 while child prints C:10. Partial credit may be given if parts are correct, summing to at most 8."
}
```

---

## Question 15 [3 point(s)]

a. Suppose that the spinlock implementation is as in OS/161, which means in particular that interrupts are disabled when a thread acquires the spinlock and enabled again when the spinlock is released. Suppose that Ta and Tb are timesharing the processor in a system with only one processor. In the worst case, what is the maximum amount of time that Tb will have to spin in spinlock_acquire()? Express your answer in terms of c and q, and briefly justify your answer by identifying a situation in which Tb would have to spin that long.

```json
{
  "problem_id": "15",
  "points": 3,
  "type": "Freeform",
  "tags": ["spinlock", "synchronization", "os161"],
  "answer": "0 time units. Because interrupts are disabled while a thread holds the spinlock, Ta cannot be preempted while holding the spinlock on a single-processor system; Tb will not be able to run and spin until Ta releases and the scheduler runs Tb, so Tb does not spin.",
  "llm_judge_instructions": "Total 3 points. Award 2 points for stating the numeric answer: 0. Award 1 point for justification mentioning that interrupts are disabled while holding the spinlock and hence the holder cannot be preempted on a single CPU, so the other thread will not spin."
}
```

---

## Question 16 [3 point(s)]

b. Repeat part (a), but this time under the assumption that the system has two processors, and that Ta and Tb are running on different processors.

```json
{
  "problem_id": "16",
  "points": 3,
  "type": "Freeform",
  "tags": ["spinlock", "synchronization", "os161"],
  "answer": "c time units (i.e., Tb may spin for the duration of Ta's critical section, c).",
  "llm_judge_instructions": "Total 3 points. Award 2 points for answering 'c' (Tb spins for the holder's critical section duration). Award 1 point for justification stating that on separate processors Tb can run and busy-wait while Ta holds the lock until Ta releases it."
}
```

---

## Question 17 [3 point(s)]

c. Suppose that the spinlock implementation is similar to the one in OS/161, except that interrupts are not disabled while a thread holds the spinlock. Suppose that Ta and Tb are timesharing the processor in a system with only one processor. In the worst case, what is the maximum amount of time that Tb will have to spin when it calls spinlock_acquire()? Express your answer in terms of c and q, and briefly justify your answer by identifying a situation in which Tb would have to spin that long.

```json
{
  "problem_id": "17",
  "points": 3,
  "type": "Freeform",
  "tags": ["spinlock", "synchronization", "os161"],
  "answer": "q time units. In the worst case Ta holds the lock and is then preempted; Tb runs and spins for its quantum q before Ta gets scheduled and releases the lock.",
  "llm_judge_instructions": "Total 3 points. Award 2 points for stating 'q' as the worst-case spinning time. Award 1 point for justification describing preemption of Ta and Tb running and spinning for up to its time quantum q."
}
```

---

## Question 18 [8 point(s)]

a. Assume that each of the functions below (FuncA, FuncB, and FuncC) are being executed by different threads using the OS/161 kernel thread library. Assume that reader/writer locks have been implemented as described in the course notes and in class. Add calls to rwlock_acquire(rwlock *lk, READ_MODE) or rwlock_acquire(rwlock *lk, WRITE_MODE), and rwlock_release(rwlock *lk) and only those calls to ensure that FuncA, FuncB, and FuncC are atomic. The locks have already been declared and initialized and xlock, ylock, and zlock must be used to protect the variables x, y, and z, respectively. Additionally, your locks must not use WRITE_MODE unnecessarily, AND you must ensure that deadlock can not occur.

```json
{
  "problem_id": "18",
  "points": 8,
  "type": "Freeform",
  "tags": ["rwlock", "synchronization", "atomicity"],
  "answer": "One correct solution: FuncA acquires ylock in WRITE_MODE, acquires zlock in READ_MODE, does update, releases zlock, releases ylock. FuncB acquires xlock in WRITE_MODE, acquires zlock in READ_MODE, does update, releases zlock, releases xlock. FuncC acquires xlock in WRITE_MODE, then ylock in WRITE_MODE, acquires zlock in READ_MODE, does updates, releases zlock, releases ylock, releases xlock. Locks are acquired in a consistent global order (x then y then z where both needed) to avoid deadlock, and WRITE_MODE is only used for variables that are modified.",
  "llm_judge_instructions": "Total 8 points. Award points per function: up to 3 points for FuncA (3 = correct acquisitions/releases, correct modes, correct minimal locking and ordering; 2 = correct modes but minor ordering issue; 1 = partial), up to 3 points for FuncB (same criteria), up to 2 points for FuncC (2 = correct acquisitions/releases in correct order and modes; 1 = partial). Additionally require that overall locking ordering prevents deadlock; if a function set has correct per-function locks but inconsistent global ordering, deduct points from each function proportionally. Total cannot exceed 8."
}
```

---

## Question 19 [2 point(s)]

b. Briefly explain why deadlock can not occur with your solution.

```json
{
  "problem_id": "19",
  "points": 2,
  "type": "Freeform",
  "tags": ["rwlock", "deadlock"],
  "answer": "Deadlock cannot occur because all threads acquire locks in a consistent global order (for example, x then y then z), preventing circular wait.",
  "llm_judge_instructions": "Total 2 points. Award 2 points for stating that a consistent global lock ordering (and acquisition in that order) prevents circular wait and thus deadlock. Award 1 point for a partially correct explanation; 0 otherwise."
}
```

---

## Question 20 [2 point(s)]

c. In your solution, which if any of the functions can be executing in their critical sections concurrently. Briefly explain your answer.

```json
{
  "problem_id": "20",
  "points": 2,
  "type": "Freeform",
  "tags": ["rwlock", "concurrency"],
  "answer": "Functions that only take READ_MODE on a variable can run concurrently with other readers. In the provided solution, FuncA and FuncB can run concurrently only if they both use READ_MODE for the shared variables they access simultaneously (they both take zlock in READ_MODE), but not if one needs WRITE_MODE. Concurrency depends on whether the same variables are being written.",
  "llm_judge_instructions": "Total 2 points. Award 2 points for correctly identifying which functions may run concurrently and explaining that read locks allow concurrent readers while write locks exclude others. Award 1 point for partially correct reasoning; 0 otherwise."
}
```

---

## Question 21 [2 point(s)]

a. When PID 516 is running, what is the resulting physical address for virtual address 1999?

```json
{
  "problem_id": "21",
  "points": 2,
  "type": "Freeform",
  "tags": ["memory-management", "mmu"],
  "answer": "21999 (physical address = virtual 1999 + relocation 20000).",
  "llm_judge_instructions": "Total 2 points. Award 2 points for the exact physical address 21999. Award 1 point for showing correct arithmetic but a minor arithmetic error; 0 otherwise."
}
```

---

## Question 22 [2 point(s)]

b. When PID 516 is running, what is the resulting physical address for virtual address 2000?

```json
{
  "problem_id": "22",
  "points": 2,
  "type": "Freeform",
  "tags": ["memory-management", "mmu"],
  "answer": "22000 (physical address = virtual 2000 + relocation 20000).",
  "llm_judge_instructions": "Total 2 points. Award 2 points for the exact physical address 22000. Award 1 point for correct method but arithmetic error; 0 otherwise."
}
```

---

## Question 23 [2 point(s)]

c. Which virtual address, in which process, corresponds to physical address 2800? Indicate both a virtual address and a PID, or answer NONE if no virtual address maps to the given physical address.

```json
{
  "problem_id": "23",
  "points": 2,
  "type": "Freeform",
  "tags": ["memory-management", "mmu"],
  "answer": "3600 in PID 159 (as given in the solution mapping).",
  "llm_judge_instructions": "Total 2 points. Award 2 points for exactly the virtual address and PID that map to physical 2800 (3600, PID 159). Award 0 if the mapping is incorrect."
}
```

---

## Question 24 [2 point(s)]

d. Which virtual address, in which process, corresponds to physical address 7100? Indicate both a virtual address and a PID, or answer NONE if no virtual address maps to the given physical address.

```json
{
  "problem_id": "24",
  "points": 2,
  "type": "Freeform",
  "tags": ["memory-management", "mmu"],
  "answer": "NONE",
  "llm_judge_instructions": "Total 2 points. Award 2 points if the student answers NONE (no virtual address maps to physical 7100). Award 0 otherwise."
}
```

---

## Question 25 [2 point(s)]

e. If process 100 is running and a context switch occurs to process 230, briefly describe the steps the kernel takes to set up the MMU.

```json
{
  "problem_id": "25",
  "points": 2,
  "type": "Freeform",
  "tags": ["memory-management", "mmu"],
  "answer": "The kernel updates the MMU registers for the new process: load the relocation/base register and the limit/max-address (or page table base) appropriate for process 230 (i.e., set the relocation and limit registers to the values for PID 230).",
  "llm_judge_instructions": "Total 2 points. Award 2 points for naming the necessary MMU register updates (relocation/base and limit/max-address or page table base) and stating they are set to the values for the incoming process. Award 1 point for partially correct description; 0 otherwise."
}
```