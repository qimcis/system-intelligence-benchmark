# COMP 350 Fall 2013 Midterm

```json
{
  "exam_id": "comp_350_fall_2013_midterm",
  "test_paper_name": "COMP 350 Fall 2013 Midterm",
  "course": "COMP 350",
  "institution": "University of Waterloo",
  "year": 2013,
  "score_total": 70,
  "num_questions": 8
}
```

---

## Question 1 [10 point(s)]

Problem 1 (10 marks)
a.(2 mark(s)) Explain how Mesa-style condition variables differ from Hoare-style condition variables.
b.(2 mark(s)) How does a syscall differ from a normal function call? Identify two distinct differences.
c.(2 mark(s)) What is the difference between an exception and an interrupt?
d.(2 mark(s)) What does it mean to provide a “fair” implementation of a synchronization mechanism?
e.(2 mark(s)) In a system that implements paging, the processor uses 37-bit virtual addresses, 44-bit physical addresses and a page size of 16 kilobytes (2^14 bytes). For the physical address, how many bits are needed to represent the offset, and how many bits are needed to represent the frame number? Explain.

```json
{
  "problem_id": "1",
  "points": 10,
  "type": "Freeform",
  "tags": ["miscellaneous","thread-fork","forking","system-calls","interrupts","paging"],
  "answer": "a) Mesa-style condition variables: the thread that calls cv_signal or cv_broadcast continues execution; the woken thread is merely made runnable and must re-acquire the lock before proceeding. Hoare-style condition variables: the signaling thread immediately yields the lock to a waiting thread, which runs immediately; the signaling thread is suspended and resumes later. b) Syscall vs normal function call: (1) A syscall transitions from user mode to kernel mode (privilege level change) via a controlled trap/interrupt, whereas a normal function call stays in the same privilege mode and transfers control within the same address space. (2) A syscall transfers control to fixed kernel entry points under OS control and may perform I/O or privileged operations; a normal function call transfers control to a caller-specified address in user code and cannot perform privileged operations. c) Exception vs interrupt: an exception is generated by the CPU as a direct result of instruction execution (e.g., divide-by-zero, page fault); an interrupt is an asynchronous signal from external devices or other processors. d) Fair implementation: ensures no thread can starve — e.g., provides FIFO ordering for acquiring the resource so requests are served in the order they arrive. e) Page size = 2^14 bytes so offset = 14 bits. Physical address is 44 bits, so frame number bits = 44 - 14 = 30 bits. Thus offset = 14 bits, frame number = 30 bits.",
  "llm_judge_instructions": "Total 10 points. Award 2 points for each subpart (a-e). Subpart grading details: (a) 2 pts: explain that Mesa wakes make thread runnable whereas Hoare hands the CPU to the waiter immediately (partial credit 1 pt if only partial distinction captured). (b) 2 pts: one point for privilege/processor-mode distinction, one point for destination/semantics (kernel entrypoint vs user-code). (c) 2 pts: full distinction between synchronous (instruction-caused) exceptions and asynchronous interrupts. (d) 2 pts: definition of fairness (no starvation or FIFO) with brief justification. (e) 2 pts: compute offset = 14, frame bits = 30 with brief arithmetic. Provide partial credit for partially correct calculations or reasoning."
}
```

---

## Question 2 [8 point(s)]

Problem 2 (8 marks)
Consider the program below, and suppose that a single initial thread starts executing the main() function. As the initial thread runs, additional threads are created as a result of calls to thread_fork(). Answer the questions below about the output of this concurrent program.
main() {
  helper(NULL,0);
}
void
helper(void *p, unsigned long i) {  /* parameter p is not used */
  if (i < 3) {
    kprintf("%ld",i); /* print the value of i */
    thread_fork("helper1",NULL,helper,NULL,i+1); /* fork thread to run helper(NULL,i+1) */
    thread_fork("helper2",NULL,helper,NULL,i+1); /* fork thread to run helper(NULL,i+1) */
  }
  /* was i=0, as announced this should be i==0 */
  if (i==0) {
    kprintf("%ld",i);
  }
  thread_exit();
}
Which of the following outputs could possibly be generated by the concurrent program shown above? Write YES after each output that could possibly be generated, and write NO after each output that could not possibly be generated.
Note: to avoid rewarding random guessing, the marking scheme for this question awards points only for 5 or more correct answers.
a. 01221220
b. 01120222
c. 01342560
d. 01222120
e. 01122220
f. 01234560
g. 01212220
h. 00112222

```json
{
  "problem_id": "2",
  "points": 8,
  "type": "Freeform",
  "tags": ["concurrency","threads","forking"],
  "answer": "a. 01221220 YES\nb. 01120222 YES\nc. 01342560 NO\nd. 01222120 NO\ne. 01122220 YES\nf. 01234560 NO\ng. 01212220 YES\nh. 00112222 YES",
  "llm_judge_instructions": "Total 8 points. Award 1 point for each line (a-h) that is correctly labeled YES or NO. Full credit = 8/8. Partial credit = number correct (1 point each)."
}
```

---

## Question 3 [8 point(s)]

Problem 3 (8 marks)
For the program shown below, fill in the table at the bottom of the page to show the output that would be printed by both the parent and child processes. Briefly explain how you arrived at your solution.
int x;
main()
{
  int rc;
  x = 0;
  rc = fork();
  if (rc == 0) {
    x = 10;
    printf("A: %d\n", x);
  } else {
    printf("B: %d\n", x);
    x = 100;
  }
  printf("C: %d\n", x);
}

```json
{
  "problem_id": "3",
  "points": 8,
  "type": "Freeform",
  "tags": ["forking","processes","memory","printf"],
  "answer": "Parent:\nB: 0\nC: 100\n\nChild:\nA: 10\nC: 10\n\nExplanation: fork() creates a copy of the process; after fork the child sets its x to 10 while the parent sets x to 100 only after printing B: 0. Each process then executes the final printf with their own copy of x.",
  "llm_judge_instructions": "Total 8 points. Award 2 points for each correct printed line: parent B: 0 (2 pts), parent C: 100 (2 pts), child A: 10 (2 pts), child C: 10 (2 pts). If any of these lines is missing or incorrect, deduct accordingly. Award up to 2 pts for a correct concise explanation linking fork and separate address spaces."
}
```

---

## Question 4 [Skipped]

Note: This problem includes diagrams/tracings. It has been omitted per the exam restrictions about figures/diagrams.

---

## Question 5 [13 point(s)]

Problem 5 (13 marks)
Suppose that a system initially has only a single thread (T1), which is running the function f1(). f1() calls thread_fork() to create a new thread, T2, to run function f2() concurrently with T1. These two threads and the functions they execute are illustrated in the two columns of the figure below.
As illustrated in the figure, thread T1 calls function fb(), and thread T2 calls functions fa() and fc().
Your task is to synchronize the calls to fa(), fb(), and fc() so that the following synchronization rules are enforced:
• function fa() finishes before function fb() is called, and
• function fb() finishes before function fc() is called.
Show how to use semaphore(s) to enforce these synchronization rules by adding P() and V() calls in suitable places in functions f1() and f2() in the diagram below. You must also declare (at the top of the diagram) global variables to point to any semaphores you use in your solution. Finally, you must include sem_create calls in suitable places in f1() and/or f2() to create and initialize the semaphores you need. Be sure that your sem_create() calls show the initial semaphore value for each newly created semaphore.
Do not use any synchronization primitives or techniques other than semaphores. Keep your solution as simple as possible - unnecessarily complex solutions may be penalized.

```json
{
  "problem_id": "5",
  "points": 13,
  "type": "Freeform",
  "tags": ["semaphores","synchronization","os161","threads"],
  "answer": "/* Global semaphore declarations */\nstruct semaphore *sa;\nstruct semaphore *sb;\n\n/* f1 (T1): create semaphores and enforce ordering */\nvoid f1() {\n  /* create semaphores with initial value 0 */\n  sa = sem_create('sa', 0);\n  sb = sem_create('sb', 0);\n  /* create thread T2 to run f2() */\n  thread_fork(..., f2, ...);\n\n  /* wait for fa() to finish */\n  P(sa);\n  /* call fb() */\n  fb();\n  /* signal that fb() is done */\n  V(sb);\n  thread_exit();\n}\n\n/* f2 (T2): run fa(), then wait for fb before running fc() */\nvoid f2() {\n  fa();\n  /* signal that fa() is finished */\n  V(sa);\n  /* wait for fb() to finish */\n  P(sb);\n  fc();\n  thread_exit();\n}",
  "llm_judge_instructions": "Total 13 points. Scoring rubric: (1) 2 points for correct semaphore declarations (sa and sb) with appropriate intent. (2) 2 points for correct sem_create calls with initial value 0 for both semaphores. (3) 3 points for correct placement of P(sa) in f1 and V(sa) in f2 (ensuring fa completes before fb starts). (4) 3 points for correct placement of V(sb) in f1 and P(sb) in f2 (ensuring fb completes before fc starts). (5) 3 points for overall correctness (no other synchronization primitives used, correct ordering, and reasonable thread creation placement). Partial credit given per item."
}
```

---

## Question 6 [9 point(s)]

Problem 6 (9 marks)
Suppose that there are only two threads, Ta and Tb, running in a system. Each of the threads attempts to execute a shared critical section that is protected by a shared spinlock, by executing code like this:
spinlock_acquire(&lock)
/* execute critical section */
spinlock_release(&lock)
Each thread needs to acquire the spinlock and execute the critical section only one time, and there are no other threads running in the system.
The threads are preemptively scheduled, using a scheduling quantum of qtime units. Once a thread has acquired the spinlock, it will spend c time units executing the critical section before releasing the spinlock.
Assume that c << q.
For all of the following questions, assume that thread Ta acquires the spinlock and executes the critical section before Tb does.
a. (3 mark(s)) Suppose that the spinlock implementation is as in OS/161, which means in particular that interrupts are disabled when a thread acquires the spinlock and enabled again when the spinlock is released. Suppose that Ta and Tb are timesharing the processor in a system with only one processor. In the worst case, what is the maximum amount of time that Tb will have to spin in spinlock_acquire()? Express your answer in terms of c and q, and briefly justify your answer by identifying a situation in which Tb would have to spin that long.
b. (3 mark(s)) Repeat part (a), but this time under the assumption that the system has two processors, and that Ta and Tb are running on different processors.
c. (3 mark(s)) Suppose that the spinlock implementation is similar to the one in OS/161, except that interrupts are not disabled while a thread holds the spinlock. Suppose that Ta and Tb are timesharing the processor in a system with only one processor. In the worst case, what is the maximum amount of time that Tb will have to spin when it calls spinlock_acquire()? Express your answer in terms of c and q, and briefly explain your answer by identifying a situation in which Tb would have to spin that long.

```json
{
  "problem_id": "6",
  "points": 9,
  "type": "Freeform",
  "tags": ["spinlocks","synchronization","os161"],
  "answer": "a) 0 time units. Under OS/161-style spinlocks on a single CPU with interrupts disabled when the lock is held, once Ta acquires the lock it cannot be preempted (interrupts disabled), so Tb cannot run to spin until Ta releases; Tb will not spin. b) c time units. On two processors, Tb can run and spin while Ta holds the lock on the other CPU; Tb may spin up until Ta releases after c time units. c) q + c (worst-case up to approximately q + c). If interrupts are not disabled, Ta could be preempted after acquiring the lock and not run for up to a quantum q before resuming and then holding the lock for c time units; Tb might spin during the period Ta is preempted and the subsequent execution, so worst-case spinning is roughly q + c (give credit for clear reasoning about preemption and quantum).",
  "llm_judge_instructions": "Total 9 points. Award 3 points per part. (a) Full 3 pts if answer explains that Ta cannot be preempted while holding the lock so Tb does not spin (0 time) and justifies why; partial credit for correct reasoning but incomplete justification. (b) Full 3 pts if answer states Tb may spin for c (Ta's critical-section length) with justification; partial credit for correct idea. (c) Full 3 pts if answer states worst-case spinning is about q + c (or explains preemption could add up to a quantum plus the critical-section time) with justification; partial credit for close/related correct reasoning."
}
```

---

## Question 7 [12 point(s)]

Problem 7 (12 marks)
a.(8 point(s)) Assume that each of the functions below (FuncA, FuncB, and FuncC) are being executed by different threads using the OS/161 kernel thread library. Assume that reader/writer locks have been implemented as described in the course notes and in class. Add calls to rwlock_acquire(rwlock *lk, READ_MODE) or rwlock_acquire(rwlock *lk, WRITE_MODE), and rwlock_release(rwlock *lk) and only those calls to ensure that FuncA, FuncB, and FuncC are atomic. The locks have already been declared and initialized and xlock, ylock, and zlock must be used to protect the variables x, y, and z, respectively. Additionally, your locks must not use WRITE_MODE unnecessarily, AND you must ensure that deadlock cannot occur.

```json
{
  "problem_id": "7",
  "points": 12,
  "type": "Freeform",
  "tags": ["rwlock","locks","synchronization","atomicity"],
  "answer": "Provide rwlock_acquire and rwlock_release calls to protect accesses to x, y, and z according to the minimum required modes and a consistent acquisition order. Example safe solution:\n\nFuncA() {\n  rwlock_acquire(&ylock, WRITE_MODE);   /* writing y */\n  rwlock_acquire(&zlock, READ_MODE);    /* reading z */\n  /* critical section using y (write) and z (read) */\n  rwlock_release(&zlock);\n  rwlock_release(&ylock);\n}\n\nFuncB() {\n  rwlock_acquire(&xlock, WRITE_MODE);   /* writing x */\n  rwlock_acquire(&zlock, READ_MODE);    /* reading z */\n  /* critical section using x (write) and z (read) */\n  rwlock_release(&zlock);\n  rwlock_release(&xlock);\n}\n\nFuncC() {\n  /* acquire in global order x then y then z to avoid deadlock */\n  rwlock_acquire(&xlock, WRITE_MODE);   /* writing x */\n  rwlock_acquire(&ylock, WRITE_MODE);   /* writing y */\n  rwlock_acquire(&zlock, READ_MODE);    /* reading z */\n  /* critical section using x,y (write) and z (read) */\n  rwlock_release(&zlock);\n  rwlock_release(&ylock);\n  rwlock_release(&xlock);\n}\n",
  "llm_judge_instructions": "Total 12 points. Award 4 points per function (FuncA, FuncB, FuncC). For each function: 2 pts for using the minimal correct mode(s) on each lock protecting accessed variables (e.g., WRITE_MODE for writes, READ_MODE for reads), and 2 pts for acquiring and releasing locks in a safe order (consistent global ordering to prevent deadlock) and releasing them correctly. Partial credit given per lock correctness and ordering."
}
```

---

## Question 8 [10 point(s)]

Problem 8 (10 marks)
Suppose that a system uses a single CPU with an MMU that uses a relocation register and a max address (or address limit) register to perform dynamic relocation. Several processes are running in this system. Each process has a simple virtual address space with virtual address ranging from 0 to the maximum address (or limit address) for that process. The kernel maintains a list of processes, their maximum virtual address (limit address) and where in physical memory each process is located (the relocation address), as shown below. All of the addresses used in this problem are decimal (base 10) numbers.
PID  Max Addr  Relocation Addr
100   1000      8000
123   2000      12
159   3000      2200
230   3000      10000
393   1000      6000
516   2000      20000
Where possible perform each of the address translations described below. Assume the kernel takes the necessary steps to set up the MMU before running each process. When the address translation is not possible explain why. In all cases be sure to describe how you arrived at your answer. Assume all addresses are in decimal.
a.(2 mark(s)) When PID 516 is running, what is the resulting physical address for virtual address 1999?
b.(2 mark(s)) When PID 516 is running, what is the resulting physical address for virtual address 2000?
c.(2 mark(s)) Which virtual address, in which process, corresponds to physical address 2800? Indicate both a virtual address and a PID, or answer “NONE” if no virtual address maps to the given physical address.
d.(2 mark(s)) Which virtual address, in which process, corresponds to physical address 7100. Indicate both a virtual address and a PID, or answer “NONE” if no virtual address maps to the given physical address.
e.(2 mark(s)) If process 100 is running and a context switch occurs to process 230, briefly describe the steps the kernel takes to set up the MMU.

```json
{
  "problem_id": "8",
  "points": 10,
  "type": "Freeform",
  "tags": ["virtual-memory","address-translation","mmu"],
  "answer": "a) For PID 516: relocation = 20000. Physical = relocation + virtual = 20000 + 1999 = 21999. b) For PID 516 and virtual 2000: physical = 20000 + 2000 = 22000. Note: if virtual 2000 is equal to the limit, it is still within 0..2000 inclusive only if the limit is >=2000; here assume limits are inclusive as given. c) Physical 2800 falls in the range for PID 159 whose relocation is 2200 and max addr 3000: virtual = 2800 - 2200 = 600; so virtual 600 in PID 159 maps to physical 2800. d) Physical 7100: check processes' relocation ranges: PID 393 has relocation 6000 and max addr 1000 so covers physical 6000..6999 (not 7100). PID 230 relocation 10000 covers 10000..12999. PID 100 relocation 8000 covers 8000..8999. PID 516 relocation 20000 covers 20000..21999. PID 123 relocation 12 covers 12..2011. PID 159 relocation 2200 covers 2200..5199. None map to 7100, so answer = NONE. e) To switch from PID 100 to PID 230 the kernel updates the MMU registers: it writes process 230's relocation address (10000) into the relocation register and writes process 230's max-address/limit into the limit register; it may also flush any TLB entries if present and perform any necessary cache/TLB maintenance.",
  "llm_judge_instructions": "Total 10 points. Award 2 points for each correct subpart (a-e). For (a)-(b): 2 pts each for correct physical address computation and brief justification. For (c)-(d): 2 pts each for locating a matching process or correctly answering NONE with justification. For (e): 2 pts for listing the necessary MMU register updates (relocation and limit) and mentioning TLB flush if applicable."
}
```