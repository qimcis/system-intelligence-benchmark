# COMP 350 Fall 2013 Midterm

```json
{
  "exam_id": "comp_350_fall_2013_midterm",
  "test_paper_name": "COMP 350 Fall 2013 Midterm",
  "course": "COMP 350",
  "institution": "University of Waterloo",
  "year": 2013,
  "score_total": 57,
  "num_questions": 6
}
```

---

## Question 1 [10 point(s)]

Problem 1 (10 marks)

a. Explain how Mesa-style condition variables differ from Hoare-style condition variables.

b. How does a syscall differ from a normal function call? Identify two distinct differences.

c. What is the difference between an exception and an interrupt?

d. What does it mean to provide a “fair” implementation of a synchronization mechanism?

e. In a system that implements paging, the processor uses 37-bit virtual addresses, 44-bit physical addresses and a page size of 16 kilobytes (2^14 bytes). For the physical address, how many bits are needed to represent the offset, and how many bits are needed to represent the frame number? Explain your answer.

```json
{
  "problem_id": "1",
  "points": 10,
  "type": "Freeform",
  "tags": ["condition-variables", "system-calls", "interrupts", "paging"],
  "answer": "a) Mesa-style vs Hoare-style: In Mesa-style, the signaling thread continues to run after cvsignal/cvbroadcast; in Hoare-style, the signaling thread yields the lock and the waiting thread continues, typically with the lock transferred.\\n\\nb) Differences between a syscall and a normal function call: (1) syscall transfers control to kernel code (kernel mode) whereas a normal function call executes within the user/application context; (2) syscall invokes kernel code (and potentially switches to privileged mode) whereas a function call invokes application code; (3) syscall changes processor mode to privileged as needed; (4) the control flow and address space context differ. (Two distinct differences are required; these capture the key separation.)\\n\\nc) An exception is generated by the execution of an instruction; an interrupt is a signal from a device or another processor.\\n\\nd) A “fair” synchronization mechanism typically ensures that starvation cannot occur, or ensures that access to the critical section is granted in a strictly FIFO order.\\n\\ne) Offset bits = 14 (since page size is 2^14 bytes); frame number bits = 44 − 14 = 30. Explanation: the offset is determined by the page size; the remaining bits form the physical frame number.",
  "llm_judge_instructions": "Award 10 points total: 2 points per subpart (a–e). For (a), award full points if the distinction between Mesa and Hoare style is correct; for (b), award points for identifying two accurate differences between syscalls and regular function calls; for (c), correct definition; for (d), correct interpretation; for (e), correct bit calculations and explanation."
}
```

---

## Question 2 [8 point(s)]

Problem 2 (8 marks)

Consider the program below, and suppose that a single initial thread starts executing the main() function. As the initial thread runs, additional threads are created as a result of calls to thread_fork(). Answer the questions below about the output of this concurrent program.

main() {
  helper(NULL,0);
}
void helper(void *p, unsigned long i) {  /* parameter p is not used */
  if (i < 3) {
    kprintf("%ld",i); /* print the value of i */
    thread_fork("helper1",NULL,helper,NULL,i+1); /* fork thread to run helper(NULL,i+1) */
    thread_fork("helper2",NULL,helper,NULL,i+1); /* fork thread to run helper(NULL,i+1) */
  }
  /* was i=0, as announced this should be i==0 */
  if (i==0) {
    kprintf("%ld",i);
  }
  thread_exit();
}

Which of the following outputs could possibly be generated by the concurrent program shown above? Write YES after each output that could possibly be generated, and write NO after each output that could not possibly be generated.
Note: to avoid rewarding random guessing, the marking scheme for this question awards points only for 5 or more correct answers.

a. 01221220
b. 01120222
c. 01342560
d. 01222120
e. 01122220
f. 01234560
g. 01212220
h. 00112222

```json
{
  "problem_id": "2",
  "points": 8,
  "type": "ExactMatch",
  "tags": ["concurrency", "threads", "fork"],
  "choices": ["01221220", "01120222", "01342560", "01222120", "01122220", "01234560", "01212220", "00112222"],
  "answer": "A,B,E,G,H",
  "llm_judge_instructions": "Award 1 point for each option correctly labeled YES/NO. Total 8 possible; full points awarded if all 6 or more of the correct YES/NO labels are identified. Partial credit should reflect the number of correctly classified options."
}
```

---

## Question 3 [8 point(s)]

Problem 3 (8 marks)

For the program shown below, fill in the table at the bottom of the page to show the output that would be printed by both the parent and child processes. Briefly explain how you arrived at your solution. Assume that all function, library and system calls are successful. If you need to make additional assumptions be sure to clearly state them.

int x;
main()
{
  int rc;
  x = 0;
  rc = fork();
  if (rc == 0) {
     x = 10;
     printf("A: %d\n", x);
  } else {
     printf("B: %d\n", x);
     x = 100;
  }
  printf("C: %d\n", x);
}

```json
{
  "problem_id": "3",
  "points": 8,
  "type": "Freeform",
  "tags": ["process-synchronization", "fork", "memory"],
  "answer": "Parent: B: 0\\nC: 100\\nChild: A: 10\\nC: 10\\nNo other results are possible. Fork creates a copy of the process so x is not shared. ",
  "llm_judge_instructions": "Award 8 points for the exact parent/child outputs as shown, plus the explanation about fork semantics. Partial credit may be given for partially correct parent/child breakdown."
}
```

---

## Question 4 [9 point(s)]

Problem 6 (9 marks)

Suppose that there are only two threads, Ta and Tb, running in a system. Each of the threads attempts to execute a shared critical section that is protected by a shared spinlock, by executing code like this:
spinlock_acquire(&lock)
/* execute critical section */
spinlock_release(&lock)
Each thread needs to acquire the spinlock and execute the critical section only one time, and there are no other threads running in the system.
The threads are preemptively scheduled, using a scheduling quantum of qtime units. Once a thread has acquired the spinlock, it will spend c time units executing the critical section before releasing the spinlock.
Assume that c << q.

a. Suppose that Ta and Tb are timesharing the processor in a system with only one processor. In the worst case, what is the maximum amount of time that Tb will have to spin in spinlock_acquire()? Express your answer in terms of c and q, and briefly justify your answer by identifying a situation in which Tb would have to spin that long.

b. Repeat part (a), but this time under the assumption that the system has two processors, and that Ta and Tb are running on different processors.

c. Suppose that the spinlock implementation is similar to the one in OS/161, except that interrupts are not disabled while a thread holds the spinlock. Suppose that Ta and Tb are timesharing the processor in a system with only one processor. In the worst case, what is the maximum amount of time that Tb will have to spin when it calls spinlock_acquire()? Express your answer in terms of c and q, and briefly justify your answer.

```json
{
  "problem_id": "6",
  "points": 9,
  "type": "Freeform",
  "tags": ["spinlocks", "synchronization", "multithreading"],
  "answer": "a) 0. Ta cannot be interrupted once it has acquired the spinlock, so Tb cannot request the lock until Ta releases it; Tb will not spin.\\nb) ctime units.\\nc) qtime units.",
  "llm_judge_instructions": "Award full points for the three parts if correct. Provide partial credit if any part is only partially correct."
}
```

---

## Question 5 [12 point(s)]

Problem 7 (12 marks)

Assume that each of the functions below (FuncA, FuncB, and FuncC) are being executed by different threads using the OS/161 kernel thread library. Assume that reader/writer locks have been implemented as described in the course notes and in class. Add calls to rwlock_acquire(rwlock *lk, READ_MODE) or rwlock_acquire(rwlock *lk, WRITE_MODE), and rwlock_release(rwlock *lk), and only those calls to ensure that FuncA, FuncB, and FuncC are atomic. The locks have already been declared and initialized and xlock, ylock, and zlock must be used to protect the variables x, y, and z, respectively. Additionally, your locks must not use WRITE MODE unnecessarily, AND you must ensure that deadlock can not occur.

a. (8 mark(s)) Provide the modified code snippets for FuncA, FuncB, and FuncC showing the required rwlock_acquire and rwlock_release calls to ensure atomicity.

b. (2 mark(s)) Briefly explain why deadlock cannot occur with your solution.

c. (2 mark(s)) In your solution, which if any of the functions can be executing in their critical sections concurrently? Briefly explain your answer.

```json
{
  "problem_id": "7",
  "points": 12,
  "type": "Freeform",
  "tags": ["reader-writer-locks", "synchronization", "locks"],
  "answer": "a) Provided solution uses a fixed lock acquisition order: FuncA() acquires ylock WRITE, zlock READ; then possibly updates y; releases zlock and ylock. FuncB(int i) acquires xlock WRITE, zlock READ; if (i == z) || (i == x) then x = z + x; releases zlock and xlock. FuncC() acquires xlock WRITE, ylock WRITE, zlock READ; performs x = y + x + z; y = z + x; releases zlock, ylock, xlock. b) Deadlock cannot occur because locks are always acquired in the same order (x, y, z). c) FuncA and FuncB can be executed concurrently because the only shared variable between them is z and it is read-only in FuncA and read in FuncB; thus they do not contend for writes on the same shared data.",
  "llm_judge_instructions": "Award up to 12 points for correct code modifications (8 points for part a, 2 for b, 2 for c)."
}
```

---

## Question 6 [10 point(s)]

Problem 8 (10 marks)

Suppose that a system uses a single CPU with an MMU that uses a relocation register and a max address (or address limit) register to perform dynamic relocation. Several processes are running in this system. Each process has a simple virtual address space with virtual address ranging from 0 to the maximum address (or limit address) for that process. The kernel maintains a list of processes, their maximum virtual address (limit address) and where in physical memory each process is located (the relocation address), as shown below. All of the addresses used in this problem are decimal (base 10) numbers.

PID | Max Addr | Relocation Addr
100 | 1000 | 8000
123 | 2000 | 12
159 | 3000 | 220
393 | 3000 | 10000
516 | 1006 | 000
200 | 20000 | 200

Where possible perform each of the address translations described below. Assume the kernel takes the necessary steps to set up the MMU before running each process. When the address translation is not possible explain why. In all cases be sure to describe how you arrived at your answer. Assume all addresses are in decimal.

a. When PID 516 is running, what is the resulting physical address for virtual address 1999?

b. When PID 516 is running, what is the resulting physical address for virtual address 2000?

c. Which virtual address, in which process, corresponds to physical address 2800? Indicate both a virtual address and a PID, or answer “NONE” if no virtual address maps to the given physical address.

d. Which virtual address, in which process, corresponds to physical address 7100? Indicate both a virtual address and a PID, or answer “NONE” if no virtual address maps to the given physical address.

e. If process 100 is running and a context switch occurs to process 230, briefly describe the steps the kernel takes to set up the MMU.

```json
{
  "problem_id": "8",
  "points": 10,
  "type": "Freeform",
  "tags": ["virtual-memory", "address-translation", "mmu"],
  "answer": "a) 21999. Phys = Virtual (1999) + Relocation Reg (20000) = 21999. b) 22000. Phys = Virtual (2000) + Relocation Reg (20000) = 22000. This wasn’t meant to be a trick question or so easy. The PID was supposed to be 393. c) 3600 by PID 159. Base addr = 2200 and 2800 was accessed so 600 is the difference. So add 600 to the base virtual address (0) = 600. d) NONE. e) It needs to copy 3000 into the max addr / limit register and 10000 into the relocation reg.",
  "llm_judge_instructions": "Award full points for all subparts answered correctly. Partial credit may be given for partial translations if justified."
}
```